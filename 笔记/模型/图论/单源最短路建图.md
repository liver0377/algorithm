### 热浪

![image-20220805140204978](http://www.cdn.liver0377.xyz/typora/202208051402042.png)

![image-20220805140215264](http://www.cdn.liver0377.xyz/typora/202208051402309.png)



**解题思路**

- 这题就是一个单源最短路经问题，直接套用模板即可
- 这里时间复杂度最小的是O(m)的`spfa`算法



**代码实现**

```cc
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>

using std::queue;
using std::cin;
using std::cout;
using std::endl;

const int N = 2510;
const int M = 6210 * 2;

int h[N], e[M], ne[M], w[M], idx;
bool st[N];
int dist[N];
int n, m, start, end;

void add(int a, int b, int c) {
    w[idx] = c, e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

void spfa() {
    memset(dist, 0x3f, sizeof dist);
    dist[start] = 0;
    
    queue<int> que;
    que.push(start);
    st[start] = true;
    
    while (que.size()) {
        auto t = que.front();
        que.pop();
        st[t] = false;
        
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            if (dist[j] > dist[t] + w[i]) {
                dist[j] = dist[t] + w[i];
                if (!st[j]) {
                    que.push(j);
                    st[j] = true;
                }
            }
        }
    }
}

int main() {
    cin >> n >> m >> start >> end;
    
    memset(h, -1, sizeof h);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
        add(b, a, c);
    }
    
    spfa();
    
    cout << dist[end] << endl;
    return 0;
}
```





### 信使

![image-20220805144020451](http://www.cdn.liver0377.xyz/typora/202208051440501.png)

![image-20220805144032892](http://www.cdn.liver0377.xyz/typora/202208051440933.png)



**解题思路**

这是一个类似广播的过程，当一个节点收到信时，为了保证送信时间最短，应该向周围所有的点发送信

考虑任意一个点，它第一次收到指挥部的信时，所花费的时间就是它到指挥部之间的最短距离，因此，只需要求出所有点到指挥部之间

的最短距离，然后求出其中最大的最短距离即可

- 题意解读

  给定`n`个点，`m`条无向边的图，求出所有点中，到点1的最短距离的最大值

- 同样套用`Dijkstra`或`spfa`模板即可





**代码实现**

```cc
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>

using namespace std;

const int N = 110;
const int M = 210 * 2;

#define x first
#define y second
typedef pair<int, int> PII;

int h[N], e[M], ne[M], w[M], idx;
bool visited[N];
int dist[N];
int n, m;

void add(int a, int b, int c) {
    w[idx] = c, e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

void dijkstra() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    
    priority_queue<PII, vector<PII>, greater<PII>> hp;
    hp.push({0, 1});
    
    while (hp.size()) {
        PII t = hp.top();
        hp.pop();
        
        int v = t.y;
        int distance = t.x;
        if (visited[v]) continue;
        visited[v] = true;
        
        for (int i = h[v]; i != -1; i = ne[i]) {
            int j = e[i];
            if (dist[j] > distance + w[i]) {
                dist[j] = distance + w[i];
                hp.push({dist[j], j});
            }
        }
        
    }
}
int main() {
    cin >> n >> m;
    
    memset(h, -1, sizeof h);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
        add(b, a, c);
    }
    
    dijkstra();
    
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        if (dist[i] == 0x3f3f3f3f) {
            ans = -1;
            break;
        }
        ans = max(ans, dist[i]);
    }
    
    cout << ans << endl;
    return 0;
    
}
```





### 香甜的黄油

![image-20220805154650915](http://www.cdn.liver0377.xyz/typora/202208051546977.png)

![image-20220805154701258](http://www.cdn.liver0377.xyz/typora/202208051547306.png)



**解题思路**

- 题意转换

  给定一个`n`个顶点, `m`条边的图，选定其中的`c`个点，以`n`个顶点中的任意一个点为终点，求该`c`个点到该终点的距离最小和

- 复杂度分析

  若终点固定，则只需要求出`c`个点到终点的最短路径和即可，因此只需要枚举出所有可能的终点，求单源最短路径即可

  - 朴素Dijkstra: O(n^2)

    时间复杂度为O(c * n ^ 2), 500 * 800 ^ 2 = 3.2 * 10^8, 不可取

  - 堆优化Dijkstra: O(m \*lg(n))

    时间复杂度为O(c \* m \*lg(n)), 500 * 1450 * lg(800) = 1.5 * 10^6, 可取

  - spfa: O(m)(最坏情况O(nm))

    时间复杂度为O(c * m), 大概也是10^6， 可取



**代码实现**

```cc
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>

using namespace std;

const int N = 810;
const int M = 1460 * 2;

typedef long long LL;

int h[N], e[M], ne[M], w[M], idx;
bool st[N];
int cows[510];
int nums[N];
int dist[N];
int cnt, n, m;
LL ans = 0x3f3f3f3f;

void add(int a, int b, int c) {
    w[idx] = c, e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

void spfa(int start) {
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);
    dist[start] = 0;
    
    queue<int> q;
    q.push(start);
    st[start] = true;
    
    while (q.size()) {
        auto t = q.front();
        q.pop();
        st[t] = false;
        
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            if (dist[j] > dist[t] + w[i]) {
                dist[j] = dist[t] + w[i];
                if (!st[j]) {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    
    LL sum = 0;     
    for (int i = 0; i < cnt; i++) {
        if (dist[cows[i]] >= 0x3f3f3f3f) return;
        sum += dist[cows[i]];
    }
    ans = min(ans, sum);
}

int main() {
    cin >> cnt >> n >> m;
    for (int i = 0; i < cnt; i++) {
        cin >> cows[i];
    }
    memset(h, -1, sizeof h);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
        add(b, a, c);
    }
    
    for (int start = 1; start <= n; start++) {
        spfa(start);
    }
    
    cout << ans << endl;
    return 0;
}

```





### 最小花费

![image-20220805163810204](http://www.cdn.liver0377.xyz/typora/202208051638274.png)



**解题思路**

- 该题中需要对最短路模型中的权值进行修改
- 这里很明显需要的是乘法而不是加法，可以将权值`w`设置为(1 - z%), 这样的话, `dist[x]`表示点`x`到起点的路径的`w[i]`的乘积
- 若想要A的费用最小，就需要走“最短路径”，也就是`dist[B]`**最大**的路径
- 应用到代码上，只需要将加法改为乘法，每次选择最大的`dist[x]`即可, 初始应该将起点的`dist`设置为1，其他点的`dist`设置为0





**代码实现**

```cc
#include <iostream>
#include <algorithm>
#include <cstring>
#include <iomanip>

using std::cin;
using std::cout;
using std::endl;
using std::setprecision;

const int N = 2010;
const int M = (1e5 + 10) * 2;

int h[N], e[M], ne[M], idx;
double w[M], dist[N];
bool visited[N];
int n, m, start, end;
double ans;

void add(int a, int b, double z) {
    w[idx] = z, e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

void dijkstra() {
    memset(dist, 0, sizeof dist);
    dist[start] = 1;
    
    for (int i = 0; i < n - 1; i++) {
        int x = -1;
        for (int j = 1; j <= n; j++) {
            if (!visited[j] && (x == -1 || dist[j] > dist[x])) {
                x = j;
            }
        }
        
        visited[x] = true;
        for (int j = h[x]; j != -1; j = ne[j]) {
            int k = e[j];
            if (dist[k] < dist[x] * w[j]) {
                dist[k] = dist[x] * w[j];
            }
        }
    }
    
    ans = 100.0 / dist[end];
}

int main() {
    cin >> n >> m;
    
    memset(h, -1, sizeof h);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        double z = (100.0 - c) / 100;
        add(a, b, z);
        add(b, a, z);
    }
    
    cin >> start >> end;
    dijkstra();
    
    cout << std::fixed << setprecision(8) <<  ans << endl;
    
    return 0;
}
```







### 最优乘车



![image-20220805181145284](http://www.cdn.liver0377.xyz/typora/202208051811347.png)

![image-20220805181156689](http://www.cdn.liver0377.xyz/typora/202208051811741.png)



**解题思路**

- 在一条巴士线路上，可以从一个站点乘坐**一趟**到达该线路上，该站点后面的任意一个站点

- 题干中要求出的是换乘的次数，也就是乘坐**公交趟数  - 1**

- 建图方式如下

  - 对任意一条公交线路上的任意一个站点，对其后面的所有站点均建立一条**边权为1**的边

    ![image-20220805181908812](http://www.cdn.liver0377.xyz/typora/202208051819850.png)

- 接下来就变成了一个单源最短路问题

- 由于不知道边的数目，因此不能使用邻接表，只能使用邻接矩阵





**代码实现**

```cc
#include <iostream>
#include <cstring>
#include <sstream>
#include <queue>

using namespace std;

const int N = 510;

bool g[N][N];
int stops[N];
int dist[N];
int m, n;

void bfs() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    queue<int> q;
    q.push(1);
    
    while (q.size()) {
        auto t = q.front();
        q.pop();
        
        for (int i = 1; i <= n; i++) {
            if (g[t][i] && dist[i] > dist[t] + 1) {
                // 由于边权为1，因此只有第一次搜索到点i时才会进入
                dist[i] = dist[t] + 1;
                q.push(i);
            }
        }
    }
    
}
int main() {
    string line;
    getline(cin, line);
    stringstream ss(line);
    ss >> m >> n;
    for (int i = 0; i < m; i++) {
        getline(cin, line);
        stringstream ss(line);
        
        int cnt = 0, p = 0;
        while (ss >> p) {
            stops[cnt ++] = p;
        }
       
        for (int j = 0; j < cnt; j++) {
            for (int k = j + 1; k < cnt; k++) {
                g[stops[j]][stops[k]] = true;
            }
        }
    }
    
    bfs();
    
    if (dist[n] == 0x3f3f3f3f) puts("NO");
    else cout << (dist[n] ? dist[n] - 1 : 0);   // 特判0趟的情况
    
    return 0;
}
```

