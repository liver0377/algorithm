### 解方程

![image-20220918144213154](http://www.cdn.liver0377.xyz/typora/202209181442208.png)



**解题思路**

- 结论: 若`a`有k个1, 那么解的数量为2 ^ k - 1

- 证明:

  考虑`a`的所有位全部为1, 那么在`a - x`时是不会发生借位的, 也就是说, 每一位之间是独立的, 考虑任意一位1

  - 1 - 1 == 1 ^ 1

    1 - 0 == 1 ^ 0

  也就是说, 对于`a`中的任意一个1, `x`中与它对应的位无论是1还是0都可以

  考虑`a`中的任意一位0, 在`a - x`时

  - 0 - 0  == 0 ^ 0

    因此当`a`的某一位为0时, `x`对应的位填0没有问题

    0 - 1 ? 0 ^ 1

    当`a - x`发生0 - 1的运算时, 此时`a`需要向前面的最近一位1借位, 借位之后, 该位进行`a - x`时为0

    当`a ^ x`发生0 ^ 1的运算时, 此时不需要借位, 改为进行`a ^ x`时为1

    因此, 当`a`的某一位为0时,`x`中对应的位不能填1

  综上, 当`a`的某一位为1时, `x`对应的位可以任意填, 当`a`的某一位为0时, `x`对应的位可以任意填, 方案数为$2 ^ k$, `k`为`a`中1的数目

**代码实现**

```cc
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
int T, a;

int main() {
    cin >> T;
    while (T --) {
        cin >> a;
        int cnt = 0;
        while (a) {
            if (a & 1) cnt ++;
            a >>= 1;
        }
        cout << (1 << cnt) << endl;
    }    
    return 0;
}
```

