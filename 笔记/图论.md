**图论算法复杂度分析以及应用场景**

![image-20220426210634225](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220426210634225.png)

### DFS

dfs基本上就是使用递归，包含**回溯**与**剪枝**两个操作

剪枝操作的含义便是在递归的过程中进行条件检查，如果条件不满足，那么就可以放弃递归，从递归树的角度来看，就是放弃了一个分支

**题干**

![image-20220422115006415](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220422115006415.png)

**题解**

```cpp
void dfs(int u){
    if (u == n) {
        for (int i = 0; i < n; i++) printf("%d ", path[i]);
        puts("");
    }
    
    for (int i = 1; i <= n; i++) {
        if (!st[i]) {
            path[u] = i;
            st[i] = true;   // 当前数字i已经被用过
            dfs(u + 1);
            path[u] = 0;
            st[i] = false;  // 递归结束之后紧接着恢复现场， 即回溯
        }
    }
}
```





**例题**

- [acwing843](https://www.acwing.com/problem/content/845/)     n皇后问题， 这题中使用到了剪枝
- [acwing846](https://www.acwing.com/problem/content/848/)





### BFS

BFS同样用于图的搜索，但是仅适用于所有边的权重都相同的情况下

**题干**

![image-20220422121325070](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220422121325070.png)

**题解**

STL版本

```cpp
#include <iostream>
#include <cstring>
#include <queue>

using namespace std;

const int N = 110;

typedef pair<int, int> PII;

int n, m;
int g[N][N], d[N][N];

int bfs()
{
    queue< pair<int, int> > q;

    q.push({0, 0});

    memset(d, -1, sizeof(d));

    d[0][0] = 0;


    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    while (q.size())//队列不为空
    {
        PII t = q.front();//取队头元素

        q.pop();//出队

        for (int i = 0; i < 4; i++)
        {
            int x = t.first + dx[i], y = t.second + dy[i];

            if (x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && d[x][y] == -1)
            {
                d[x][y] = d[t.first][t.second] + 1;//当前点到起点的距离
                q.push({x, y});//将新坐标入队
            }
        }
    }

    return d[n - 1][m -1];
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> g[i][j];

    cout << bfs() << endl;

    return 0;
}

```

手写队列版本

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

typedef  pair<int, int> PII;
const int N = 110;
const int dx[4] = {-1, 0, 1, 0};
const int dy[4] = {0, 1, 0, -1};

int g[N][N];
int d[N][N];
PII q[N * N];
int n, m;

int bfs() {
    int hh = 0, tt = 0;
    q[0] = {0, 0};
    memset(d, -1, sizeof(d));
    d[0][0] = 0;
    while (hh <= tt) {
        PII t = q[hh ++];
        for (int i = 0; i < 4; i++){
            int x = t.first + dx[i], y = t.second + dy[i];
            if (x >= 0 && x < n && y >=0 && y < m && 
                  g[x][y] == 0 && d[x][y] == -1) {
                      d[x][y] = d[t.first][t.second] + 1;
                      q[++ tt] = {x, y};
            }
        }
    }
    
    return d[n - 1][m - 1];
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> g[i][j];
        }
    }
    cout << bfs() << endl;
    return 0;
}
```



**例题**

- [acwing847](https://www.acwing.com/problem/content/849/)

### dijkstra

- 朴素dijkstra

  **模板**

  ```cpp
  int g[N][N];  // 存储每条边
  int dist[N];  // 存储1号点到每个点的最短距离
  bool st[N];   // 存储每个点的最短路是否已经确定
  
  // 求1号点到n号点的最短路，如果不存在则返回-1
  int dijkstra()
  {
      memset(dist, 0x3f, sizeof dist);        // 0x3f3f3f3f作为距离的“最大值”
      dist[1] = 0;                            // 自己到自己的距离为0
  
      for (int i = 0; i < n - 1; i ++ )       // 执行n-1次（自己到自己的距离已经确定）
      {
          int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点
          for (int j = 1; j <= n; j ++ )
              if (!st[j] && (t == -1 || dist[t] > dist[j]))
                  t = j;                // 如果是第一次进入的话, t == 1
  
          // 用t更新其他点的距离
          for (int j = 1; j <= n; j ++ )
              dist[j] = min(dist[j], dist[t] + g[t][j]);
  
          st[t] = true;
      }
  
      if (dist[n] == 0x3f3f3f3f) return -1;       // 不可达
      return dist[n];
  }
  ```




### 堆优化dijkstra

```cpp
int dijkstra() {
    
    priority_queue<PII, vector<PII>, greater<PII>> hp;  // first为距离，second为节点值
    d[1] = 0;
    hp.push({0, 1});
    
    while (!hp.empty()) {
        PII k = hp.top();
        hp.pop();
        int vec = k.second, dance = k.first;
        if (st[vec]) continue;
        st[vec] = true;
        
        for (int i = h[vec]; i != -1; i = ne[i]) {       // 这里采用的是邻接表
            int j = e[i];
            if (w[i] + dance < d[j]) {
                d[j] = w[i] + dance;
                hp.push({d[j], j});          // 可能会存在一个节点，多个距离的情况， 因为这里实际上访问的是边
            }
        }
    }
    if (d[n] == 0x3f3f3f3f) {
        return -1;
    }
    return d[n];
}
```

- 改用邻接表数据结构

- 使用小根堆优化查找最小距离的过程

- 小根堆可能存在冗余数据

- 算法类似BFS，因为在修改其它顶点最短距离的过程中，堆优化版本并没有遍历所有的顶点，而是遍历所有与当前选取的最小顶点有关的边

- 时间复杂度为O(m*logm)

  堆中的元素个数最多为m个，一个点可以存在多次，每当尝试更新一个点的距离时，都会唯一的访问一条边，所以需要访问一遍所有的边，而在堆中更新边时，时间复杂度为O(logm), 所以总的时间复杂度为O(m * logm)
  
  > 如果这里采用手写堆的话，可以保证堆中的元素不超过n个，因此总的时间复杂度可以变为O(m * log(n)), 不过它们是同一个量级的





### BellmanFord

bellmanFord算法的基本思想就是通过k次迭代，找到路径中边的数目不超过k的所有点到原点的距离

![image-20220425231556462](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220425231556462.png)

![image-20220425231618399](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220425231618399.png)

![image-20220425231636730](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220425231636730.png)

![image-20220425231649230](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220425231649230.png)

**模板**

```cpp
int n, m, k;                    // n表示点数，m表示边数，k是路径的最大边数 
int dist[N], backup[N];          // dist[x]存储1到x的最短路距离

// 三元组
struct Edge     // 边，a表示出点，b表示入点，w表示边的权重
{
    int a, b, w;
}edges[M];

// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford()
{
    memset(dist, 0x7f, sizeof dist);
    dist[1] = 0;

    // 如果第n次迭代仍然会松弛三角不等式（存在更新），就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i = 0; i < k; i ++ )       // 如果没有k，则用n代替k
    {
        memcpy(backup, dist, sizeof dist);      // 备份，防止读后写
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            dist[b] = min(dist[b], dist[a] + w)
        }
    }

    if (dist[n] > 0x3f3f3f3f / 2) return 0;
    return dist[n];
}
```

- 27行中的判断条件看起来很奇怪，主要是考虑到以下情况

  当d[i] 为 0x3f3f3f3f, d[j]也为0x3f3f3f3f3f, 而i, j 之间有着一条负权边的时候，当遍历到i~j这条边时，同样会更新d[j], 这就会导致

  0x3f3f3f3f的值可能会不断减小，但是一般来说，这个值不可能会减小到0x3f3f3f3f /2 





### SPFA

**模板**

```cpp
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x7f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;              // 已出队，因此队列不再包含顶点t，需要重置为false

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;       // 如果题目保证不存在负权回路（不是指负权边），则可这么写
    return dist[n];
}

```

- 用队列优化bellmanFord更新最短距离的过程，核心思想是
  - dist[u]发生改变，dist[u] + w才有可能满足< dist[u]
  - 用队列保存最短距离发生改变的顶点（其它数据结构也可以，不一定是队列）
  - 用st记录在队列中的顶点，避免重复更新
  - 由于每次只更新与出队顶点相关的边，因此不会出现“写后读”现象，故改进的bellman-ford算法不需要额外的数组保存上次迭代的结果
  - SPFA算法有点像堆优化的Dijkstra算法，但后者依赖优先队列，而前者不需要
  - 大多数情况下，Dijkstra算法能解决的问题，SPFA都比它更好，而且适用负权边，因此如果没有限制路径最大边数的情况下，优先考虑SPFA算法，如果过不了就考虑堆优化的Dijkstra算法
  - 平均时间复杂度为O(m)，最坏时间复杂度为O(mn)
- 若要判断负环，则需要额外维护一个数组cnt，用于记录各个最短路径的边数，当边数 ≥ 顶点数n时，则一定存在负环



**例题**

- [acwing852](https://www.acwing.com/problem/content/854/) 该例题中会使用到spfa判断负环







### Floyd算法

Floyd算法本质上是基于动态规划，实现起来也特别简单

**模板**

```cpp
void floyd()
{
    for (int k = 1; k <= n; k ++ )   // 最外层一定是k
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```

> 为什么最外层一定是k?
>
> f[k\][i\][j\]表示由i到达j**中间节点(不包括i, j本身)**的编号不超过k的最短路径
>
> ![image-20220426210431085](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220426210431085.png)

