### 判断质数

**模板**

```cpp
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )              // 注意循环条件
        if (x % i == 0)
            return false;
    return true;
}
```

- 判断条件的选择
  - i < n和i <= n / 2时间复杂度都是O(n)，过高
  - i * i <= n虽然时间复杂度是$O(\sqrt{n})$，但i * i可能会溢出
  - 因此最好的判别条件是i <= n / i，时间复杂度是$O(\sqrt{n})$

### 分解质因数

**模板**

```cpp
void get_prim(int n) {
    if (n < 2) return;
    
    for (int i = 2; i <= n / i; i++) {
        if (n % i == 0) {
            int cnt = 0;
            while (n % i == 0) {
                cnt ++;
                n /= i;
            }
            printf("%d %d\n", i, cnt);
        }
    }
    if (n > 1)       // 如果n > 1, 那么代表n此时是原来的n的唯一一个大于根号n的质因子
        printf("%d %d\n", n, 1);
}
```

- 注意这里如果n%i == 0的话，n一定不是合数

  - 反证法

    假设n % i == 0, 且i 为合数，那么一定有i = a * b(a, b < i ), 不妨令a <= b

    则有n % a == 0,又a < i , 所以在之前的循环当中，n /= a一定会发生，那么现在的n将不会存在

- 时间复杂度分析

  - 最好情况：log(n), 如果n == i^k ,那么在while循环当中，n就会一次性被除到1
  - 最坏情况: $\sqrt{n}$

  

### 筛选质数

**埃氏筛法**

从1\~n之间，遍历所有的质数，筛掉它们的倍数，当遍历到i时，如果i还没有被筛掉，那么表明1\~ i - 1之间没有i的质因子，因此i就是质数

由于所有的合数可以分解出质因子，因此只要选出所有质数的倍数，就会筛掉所有合数

```cpp
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];             // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) {
            primes[cnt++] = i;                  // i是当前可用的最小质数，保存到primes中
            for (int j = i + i; j <= n; j += i)
                st[j] = true;                   // 素数的倍数一定不是素数
        }
    }
}
```

- 时间复杂度:$O(nloglogn)$



**线性筛法**

线性筛选法相对于埃氏筛选法更为出色，因为在埃是筛选法中，一个数可能会被不同的质因子重复筛掉，在线性筛选法中，对于每个合数而言，都只会用其最小的质因子来将其筛去，并且**不会发生重复筛选**的情况

```cpp
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;       // 用最小质因子pr去筛合数primes[j] * i
                                            // 这里的i会逐渐从2增长到n, 如primes[0] = 2
                                            // 那么就会筛掉2 * 2, 2 * 3, 2 * 4, ... 2 * n
                                            // 如果新加入了一个质数7, 则会2 * 7, 3 * 7, 5 * 7, 7 * 7
                                            // 这些被筛掉的数是不会重复的
            if (i % primes[j] == 0) break;  // 从最小的质数开始，直至找到i的最小质因子primes[j]为止
        }
    }
}
```

- 一句话:  对于任意一个合数x, 假设pj是其最小的质因子，那么当**i**枚举到x / pj时，x就会被筛掉





### 求所有约数

采用试除法求约数

```cpp
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```



### 约数个数

![image-20220430183607486](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220430183607486.png)

- 任意n的约数p都可以表示成$p = {p1^{a1} * p2^{a2}... *pk^{ak}}$其中

  - $a1 \in {\{0, 1, 2, ..., c1\}}$

  - $a2 \in {\{0, 1, 2, ..., c2\}}$

    ...

  - $ak \in {\{0, 1, 2, ..., ck\}}$

  取值组合总共有(c1 + 1)(c2 + 1)...(ck + 1)种



**模板**

```cpp
unordered_map<int, int> primes;     // 用哈希表保存质数的指数

// 质数分解
for (int i = 2; i <= x / i; i++)
    while(x % i == 0) {
        x /= i;
        primes[i]++;
    }
if (x > 1) primes[x]++;

// 约数个数定理
LL res = 1;
for (auto elem : primes) res = res * (elem.second + 1);
```



### 约数和

![image-20220430184952418](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220430184952418.png)

- 将括号拆开之后就是所有的约数相加

**模板**

```cpp
LL res = 1;
for (auto elem : primes) {
    int p = elem.first, a = elem.second;
    LL sum = 1;
    while(a--) sum = sum * p + 1; // sum * p + 1执行a 次就可以得到括号中的式子
    res *= sum;
}
```





### 最大公约数

使用欧几里得算法(辗转相除法)求最大公约数

- 设gcd(a, b)表示a, b的公约数

- 则有gcd(a, b) = gcd(b, a % b)

- 证明

  - 假设d为a, b的公约数, 即d | a, d | b, d | ax + by

  - a % b = a - c * b, 其中c = $\lfloor {{a} \over {b}} \rfloor$
  - 满足d | ax + by形式, 故d | a % b

**模板**

```cpp
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
```

- gcd(a, 0) = a
- 时间复杂度为log(n)

