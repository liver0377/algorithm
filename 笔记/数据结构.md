### 单链表

这里使用的方法是用数组来模拟单链表，因为如果使用C++的`new`操作会比较耗时



**模板**

```cpp
const int N = 1e5 + 10;
int head, m, idx;
int e[N], ne[N];

void init() {
    idx = 0;
    head = -1;
}

void add_to_head(int x) {
    e[idx] = x;
    ne[idx] = head;
    head = idx;
    idx ++;
}

// 在下标为k的点后面插上x
void add(int k, int x) {
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx;
    idx ++;
}

// 删除下标为k的点后面的点, 这里的下标是指在e[N]中的下标
void remove(int k) {
    ne[k] = ne[ne[k]];
}

void remove_head() {
    head = ne[head];
}
```

- 这里使用到了两个数组: e[N], ne[N]

- e[i]中存储的是链表节点的值，ne[i]中存储的是链表节点的下一个节点位置，不过这里使用的是数组下标而不是地址

- 注意，这里的插入，删除等操作，针对的下标是数组下标，而不是链表下标

- 数组下标与链表下标**不是**对应的，第k个插入的数对应于数组下标k - 1

  - 例

    首先插入1, 2, 3,   那么e: [1, 2, 3], ne: [1, 2, -1], head: 0,   -1代表着空

    删除下标为0的后面的点,那么e:[1, 2, 3], ne: [**2**, 2, -1] 

    在下标为1的后面插上4, 那么e:[1, 2, 3, **4**], ne: [2, **3**, -1, **2**], 这里idx在 ++ 前等于3

- 由于使用数组来模拟链表，因此也就无法对内存进行回收，即这里存在着内存泄漏的问题，因此这种使用方法仅适用于算法题，

  而不适用与工程当中



**例题**

- [acwing826](https://www.acwing.com/problem/content/828/)





### 双链表

**模板**

```cpp
const int N = 100010;
int e[N], l[N], r[N], idx;

/** 创建双链表（含头结点和尾结点） */
void init() {
    r[0] = 1;       // 0-->head
    l[1] = 0;       // 1-->tail
    idx = 2;
}

/** 在下标为k的结点右侧插入一个结点 */
void insert(int k, int x) {
    e[idx] = x;
    r[idx] = r[k];
    l[idx] = k;
    l[r[k]] = idx;
    r[k] = idx;
    idx++;
}

/** 删除下标为k的结点 */
void remove(int k) {
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}

/** 输出 */
void print() {
    for (int i = r[0]; i != 1; i = r[i]) printf("%d ", e[i]);
}
```



**例题**

- [acwing827](https://www.acwing.com/problem/content/829/)



### 模拟栈

**模板**

```cpp
int stk[N], tt = -1;     // tt表示栈顶

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空
if (tt == -1) {...}       // 栈不为空
```

**说明**



- 栈指针 tt 的值可表示栈的实际长度



**例题**

- [acwing828](https://www.acwing.com/problem/content/830/)



### 模拟队列

**模板**

```cpp
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh > tt){...}
```



**说明**

`tt + 1 - hh`可表示队列长度



### 单调栈

单调栈满足这样一种性质，栈中的元素时单调递增或者单调递减的,  t通过下面的方法可以从一个整数序列构造出单调一个单调递增的栈

- 扫描整个序列
- 如果扫描到的元素大于栈顶等于元素，那么直接加入
- 如果扫描到的元素小于栈顶元素，那么不断弹栈，直至栈顶元素小于等于当前元素，然后将新元素加入栈顶





**模板**

```cpp
int tt;
for (int i = 0; i < n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```



**例题**

- [acwing830](https://www.acwing.com/problem/content/832/)

