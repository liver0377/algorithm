**题干**

![image-20220416160646619](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220416160646619.png)

![image-20220416160659826](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220416160659826.png)



**解题思路**

该题使用并查集的思想来做，不过需要维护额外的信息

所有的动物最终都会在一个集合当中，这里使用d[]数组来维护节点到根节点之间的距离，只要知道了两个节点到根节点之间的距离，那么就可以通过它们距离的关系来判断这两个节点的关系

- 设任意一个节点到根节点的距离d[i]为D, 那么根据D % 3 的余数可以判断其与根节点之间的关系
  - D % 3 == 1:  可以吃根节点
  - D % 3 == 2: 可以被根节点吃
  - D % 3 == 0: 和根节点是同类

- 假设有两个节点A, B, 他们到根节点的距离分别是dx, dy, 记

  - X= dx % 3 
  - Y = dy % 3

  A, B之间的关系只有三种: **A被B吃**, **B被A吃**, **AB同类**, 下面给出他们的关系图

  - A被B吃

    | X    | 0    | 1    | 2    |
    | ---- | ---- | ---- | ---- |
    | Y    | 1    | 2    | 0    |

    此时dx 与 dx满足的关系是**(dy - dx - 1) % 3 == 0**

  - B被A吃

    | Y    | 0    | 1    | 2    |
    | ---- | ---- | ---- | ---- |
    | X    | 1    | 2    | 0    |

    这种情况与上面的情况完全对称

    dx与dy之间满足的关系是**(dx - dy - 1) % 3 == 0**

  - AB同类

    | X    | 0    | 1    | 2    |
    | ---- | ---- | ---- | ---- |
    | Y    | 0    | 1    | 2    |

    dx与dy之间满足的关系是**(dx - dy) % 3 == 0 **

- 一开始时，所有的节点都在不同的集合，仅当两个节点在同一个集合中时，才能够判断两个节点之间的关系

- 当读取一句话的时候，如果发现给出的两个节点在不同的集合，此时无法判断两个节点之间的关系，那么就认为这句话是真的

  假设这两个节点分别是x, y, 它们的父节点分别为px, py, 那么就需要

  - 令p[px] = py, 即令x所在集合的根节点指向y所在集合的根节点

  - 令d[px] = ?, 这里的?需要分情况进行讨论

    - 给的话是1, x, y, 即认为x, y同类

      此时令d[px] = ? 之后，应该满足(dx + ? - dy) % 3 == 0, 所以这里令? = dy - dx

    - 给的话是2, x, y, 即认为x吃b

      此时令d[px] = ? 之后，应该满足(dx + ? - dy - 1) % 3 == 0, 所以这里令? = dy - dx -1

    > 值得注意的是，我们的x节点所在的集合可能并不止一个节点，但是我们只令x集合的根节点的d[]内容发生了改变， 可以看后面的解释

- 父节点与根节点

  这里我们的d[]数组应该既是到父节点的距离也是到根节点的距离，因为我们采用了路径压缩机制，当进行find操作之后，所有节点的父节点应该就是一个根节点

**题解**



```cpp
#include <iostream>

using namespace std;

const int N = 50010;

int n, k;
int p[N], d[N];


int find(int x) {
    if (p[x] != x) {
        int t = find(p[x]);
        d[x] += d[p[x]];      // 在接下来的路径压缩中，节点x的父亲节点将会变成根节点，因此需要加上父节点到根节点的距离
        p[x] = t;  
    }
    return p[x];
}

int main() {
    int res = 0;
    cin >> n >> k;
    
    for (int i = 1; i <= n; i++) p[i] = i; 
    while (k --) {
      int a, b, c;
      cin >> a >> b >> c;
       
      int pb = find(b), pc = find(c);
      if (b > n || c > n) {
          res ++;
      } else if (a == 1) {
                // b, c 同类
                if (pb == pc && (d[b] - d[c]) % 3 != 0) {
                    res ++;
                } else if (pb != pc) {
                    // b, c不在一个集合，此时不能判断b, c之间的关系，那么就认为它说的是真的
                    // 将b集合加入到c集合当中
                    p[pb] = pc;
                    d[pb] = d[c] - d[b];
                }
        }  else {
                // b吃c
                if (pb == pc && (d[b] - d[c] - 1) % 3 != 0) {
                  res ++; 
                } else if (pb != pc) {
                    p[pb] = pc;
                    d[pb] = d[c] - d[b] + 1;
                }
        }
    }
    
    printf("%d", res);
    return 0;
}
```

