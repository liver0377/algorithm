### 朴素Dijkstra

朴素Dijkstar使用于稠密图，时间复杂度为O(n^2)

**基本做法**

三步走

- 完成初始化工作

  - 将题目给定边长置于邻接矩阵, 其余边长均置为`0x3f3f3f3f`

  - dist[1] <-- 0 ,  dist[i] <--- +INF

- 迭代每个节点, 令S表示已经确定最短距离的节点

  伪代码:

  ```c
  for i : 0 ~ n
      t <-- 不在S中的距离最近的点
      s <-- t
      将t加入S
      dist[t] <-- min(dist[t], dist[t] + w)
  ```
  
  

**模板**

```c
int g[N][N];  // 存储每条边
int dist[N];  // 存储1号点到每个点的最短距离
bool st[N];   // 存储每个点的最短路是否已经确定

// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);        // 0x3f3f3f3f作为距离的“最大值”
    dist[1] = 0;                            // 自己到自己的距离为0

    for (int i = 0; i < n - 1; i ++ )       // 执行n-1次（自己到自己的距离已经确定）
    {
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        // 用t更新其他点的距离
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);

        st[t] = true;
    }

    if (dist[n] == 0x3f3f3f3f) return -1;       // 不可达
    return dist[n];
}
```

