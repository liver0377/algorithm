### 题干

![image-20221113142947571](http://www.cdn.liver0377.xyz/typora/202211131429833.png)



![image-20221113143057692](http://www.cdn.liver0377.xyz/typora/202211131431033.png)



**解题思路**

- 如果直接枚举每个子串再判断该串是否为回文串的话, 时间复杂度为$O(N^3)$, 会超时

- 这里可以尝试**中心拓展法**

- 该方法的思路是枚举每个回文串的可能中心点, 累加以该中心点为中心点的回文串的数目

  - 对于长度为奇数的回文串, 中心点为一个字符
  - 对于长度为偶数的回文串, 中心点为两个字符

- 假设一个串的长度为`n`, 那么可能的奇数中心点的个数为`n`, 可能的偶数中心点的个数为`n - 1`

- 这里, 可以以一种特殊的方式枚举中心点

  假设有一个长度为4的字符串, 我们按照单字符, 双字符的方式从左到右枚举中心点

  ![image-20221113143355539](http://www.cdn.liver0377.xyz/typora/202211131434324.png)

  此时中心点的左右边界的下标规律就变为了$l_i = \lfloor i / 2 \rfloor$, $r_i = l_i + i \% 2$

  

**代码实现**

```cc
class Solution {
public:
    int countSubstrings(string s) {
        int res = 0;
        for (int i = 0; i < s.size() * 2 - 1; i ++) {
            int l = i / 2;
            int r = l + i % 2;
            while (l >= 0 && r < s.size() && s[l] == s[r]) {
                l --;
                r ++;
                res ++;  // 累加以该中心店为中心的所有回文串
            }
        }

        return res;
    }
};
```

