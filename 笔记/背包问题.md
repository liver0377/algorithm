

- 前言

  背包问题属于动态规划中的一大类问题，下面这张图给出了动态规划的基本概念

![image-20220416193402031](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220416193402031.png)

- f[i][j\]表示一个状态，与一个集合相对应，而f[i\][j\]本身的值又代表这该集合的一个属性，常见的属性包括最值，个数等等

- 在动态规划中，状态不仅仅限于二维，有时还有三维四维

- 动态规划问题中最重要也是最难的点在于如果建立状态转移方程，即状态的计算

  状态的计算对应着集合的划分，这是问题的关键

- 有时可以对代码或者方程做等价的变形，已达到优化的目的，通常是一些降维的操作，常见的一个优化方法是**滚动数组**

### 0-1背包问题

**题干**

![image-20220416195715596](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220416195715596.png)



**题解**

- 解法1

  **状态表示**

  - f[i][j\]表示: **只从前i个物品当中选，物品的总体积不超过j的最大价值**

  **集合划分**

  这里将f[i][j\]对应的选法集合划分成两个子集合：

  - 包含第i个物品的选法
    该选法最大价值是f[i - 1][j\], 该集合一定存在

  - 不包含第i个物品的选法

    该选法对应的最大价值是f[i - 1\][j - v[i]] + w[i], 当j < v[i]时，该集合为空集，因此需要特判

  ```cpp
  #include <iostream>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 1010;
  int n, m;
  int v[N], w[N];
  int f[N][N];
  
  int main () {
      cin >> n >> m;
      
      for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
      
      for (int i = 1; i <= n; i++) {
          for (int j = 0; j <= m; j++) {
              f[i][j] = f[i - 1][j];
              if (j >= v[i]) {
                  f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
              }
          }
      }
      
      cout << f[n][m] << endl;
      return 0;
  }
  ```

- 解法2

  解法1的时间复杂度与空间复杂度均为O(N * V), 采用滚动数组可以将空间复杂度进一步优化至O(V)

  **滚动数组**

  

  - 滚动数组优化方法的基本思想是利用一维数组来代替二维数组

  - 在解法1中，是自上而下，自左向右进行循环，采用滚动数组之后，扫描方式变成自上向下，自右向左

    下面是原来的代码

    ```cpp
    for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                f[i][j] = f[i - 1][j];
                if (j >= v[i]) {
                    f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
                }
            }
        }
    ```

    现在想要达到的目的就是**在推f[i\][j\]的时候能够得到f[i-1\][j\]和f[i-1\][j -v[i]\]的值**

    ![image-20220416202236436](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220416202236436.png)

    当计算f[i\][j\]时，f[i\][j + 1\]以及第i行后面的所有元素，都已经在第i行的扫描过程中被覆盖成新的值了，而**f[i\][0~ j - 1\]仍然是上一行的值**，f[i-1\][j\]和f[i-1\][j -v[i]\]`都位于这些值中间，因此可以放心的拿来使用

    **优化后的代码如下**

    ```cpp
    #include <iostream>
    #include <algorithm>
    
    using namespace std;
    
    const int N = 1010;
    int n, m;
    int v[N], w[N];
    int f[N];
    
    int main () {
        cin >> n >> m;
        
        for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
        
        for (int i = 1; i <= n; i++) {
            for (int j = m; j >= v[i]; j--) {  // 当j < v[i]时，f[j - v[i]]肯定不存在，这里直接更改条件
                // 原本的f[i][j] = f[i - 1][j] 经过滚动数组优化之后变为f[j] = f[j], 没有意义，直接删了
                f[j] = max(f[j], f[j - v[i]] + w[i]);
            }
        }
        // 当调出循环时, f[j]就相当于原来的f[n][j]
        cout << f[m] << endl;
        return 0;
    }
    ```

    

### 完全背包问题

**题干**

![image-20220416205710775](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220416205710775.png)



**基本思想**

完全背包问题与0-1背包问题的解题思路十分相似

![image-20220416205841709](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220416205841709.png)

- 状态表示

  与0-1背包完全一样

  f[i\][j\]表示只从前i个物品中选，总体积不大于j的选法集合中的最大价值

- 状态计算

  由于完全背包问题一个物品可以选无限次，因此所划分的子集合也变多了

  这些子集合分别表示选k个物品i的选法, k = 0, 1, 2, 3...,  j / vi

  那么最大值就应该是`max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k)`, 遍历所有可能的k即可



**题解**

- 解法1

  普通动态规划，时间复杂度O(n^3)

  ```cpp
  #include <iostream>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 1010;
  int v[N], w[N];
  int f[N][N];
  
  int main() {
      int n, m;
      
      cin >> n >> m;
      for (int i = 1; i <= n ; i++) cin >> v[i] >> w[i];
      
      for (int i = 1; i <= n; i++) {
          for (int j = 0; j <= m; j++) {
              for (int k = 0; k * v[i] <= j; k++) {
                  f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + w[i] * k);
              }
          }
      }
      
      cout << f[n][m] << endl;
      
      return 0;
  }
  ```

- 解法2

  数学优化

  ![image-20220416212324053](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220416212324053.png)

  根据上面的图，我们可以将一次循环简单的改为一次比较

  - 循环次序不变，依旧是自上而下，自左向上

  - 当计算f[i\][j\]时, f[i - 1\][j\], f[i\][j -v\]均已经在前面的扫描过程中计算完毕，因此可以直接使用他们来代替解法1中的第三层迭代

  ```cpp
  #include <iostream>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 1010;
  int v[N], w[N];
  int f[N][N];
  
  int main() {
      int n, m;
      
      cin >> n >> m;
      for (int i = 1; i <= n ; i++) cin >> v[i] >> w[i];
      
      for (int i = 1; i <= n; i++) {
          for (int j = 0; j <= m; j++) { // 这里j不能直接从v[i]开始
              f[i][j] = f[i - 1][j];
              if (j >= v[i])
                  f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);
          }
      }
      
      cout << f[n][m] << endl;
      
      return 0;
  }
  ```

  

- 解法3

  该解法是对解法2使用滚动数组优化

  ```cpp
  #include <iostream>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 1010;
  int v[N], w[N];
  int f[N];
  
  int main() {
      int n, m;
      
      cin >> n >> m;
      for (int i = 1; i <= n ; i++) cin >> v[i] >> w[i];
      
      for (int i = 1; i <= n; i++) {
          for (int j = v[i]; j <= m; j++) {
               f[j] = max(f[j], f[j - v[i]] + w[i]);
          }
      }
      
      cout << f[m] << endl;
      
      return 0;
  }
  ```

  > 什么时候使用 j = 0, 什么时候使用j = v[i] ?           ------------> 通常来说使用滚动数组优化过后就可以使用j = v[i]
  >
  > 解法2：
  >
  > ```c
  > for (int j = 0; j <= m; j++) { // 这里j不能直接从v[i]开始
  >             f[i][j] = f[i - 1][j];
  >             if (j >= v[i])
  >                 f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);
  >         }
  > ```
  >
  > 解法3:
  >
  > ```cpp
  >  for (int j = v[i]; j <= m; j++) {
  >              // f[j] = f[j] 没有意义，直接删掉，因此当j < v[i]的时候，下面的代码根本不会执行
  >              // if (j >= v[i])
  >              f[j] = max(f[j], f[j - v[i]] + w[i]);
  >         }
  > ```

