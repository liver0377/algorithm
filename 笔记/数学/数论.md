### 判断质数

**模板**

```cpp
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )              // 注意循环条件
        if (x % i == 0)
            return false;
    return true;
}
```

- 判断条件的选择
  - i < n和i <= n / 2时间复杂度都是O(n)，过高
  - i * i <= n虽然时间复杂度是$O(\sqrt{n})$，但i * i可能会溢出
  - 因此最好的判别条件是i <= n / i，时间复杂度是$O(\sqrt{n})$

### 分解质因数

**模板**

```cpp
void get_prim(int n) {
    if (n < 2) return;
    
    for (int i = 2; i <= n / i; i++) {
        if (n % i == 0) {
            int cnt = 0;
            while (n % i == 0) {
                cnt ++;
                n /= i;
            }
            printf("%d %d\n", i, cnt);
        }
    }
    if (n > 1)       // 如果n > 1, 那么代表n此时是原来的n的唯一一个大于根号n的质因子
        printf("%d %d\n", n, 1);
}
```

- 注意这里如果n%i == 0的话，n一定不是合数

  - 反证法

    假设n % i == 0, 且i 为合数，那么一定有i = a * b(a, b < i ), 不妨令a <= b

    则有n % a == 0,又a < i , 所以在之前的循环当中，n /= a一定会发生，那么现在的n将不会存在

- 时间复杂度分析

  - 最好情况：log(n), 如果n == i^k ,那么在while循环当中，n就会一次性被除到1
  - 最坏情况: $\sqrt{n}$

  

### 筛选质数

**埃氏筛法**

从1\~n之间，遍历所有的质数，筛掉它们的倍数，当遍历到i时，如果i还没有被筛掉，那么表明1\~ i - 1之间没有i的质因子，因此i就是质数

由于所有的合数可以分解出质因子，因此只要选出所有质数的倍数，就会筛掉所有合数

```cpp
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];             // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) {
            primes[cnt++] = i;                  // i是当前可用的最小质数，保存到primes中
            for (int j = i + i; j <= n; j += i)
                st[j] = true;                   // 素数的倍数一定不是素数
        }
    }
}
```

- 时间复杂度:$O(nloglogn)$



**线性筛法**

线性筛选法相对于埃氏筛选法更为出色，因为在埃是筛选法中，一个数可能会被不同的质因子重复筛掉，在线性筛选法中，对于每个合数而言，都只会用其最小的质因子来将其筛去，并且**不会发生重复筛选**的情况

```cpp
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;       // 用最小质因子pr去筛合数primes[j] * i
                                            // 这里的i会逐渐从2增长到n, 如primes[0] = 2
                                            // 那么就会筛掉2 * 2, 2 * 3, 2 * 4, ... 2 * n
                                            // 如果新加入了一个质数7, 则会2 * 7, 3 * 7, 5 * 7, 7 * 7
                                            // 这些被筛掉的数是不会重复的
            if (i % primes[j] == 0) break;  // 从最小的质数开始，直至找到i的最小质因子primes[j]为止, 这是一步优化
        }
    }
}
```

- 一句话:  对于任意一个合数x, 假设pj是其最小的质因子，那么当**i**枚举到x / pj时，x就会被筛掉





### 求所有约数

采用试除法求约数

```cpp
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```



### 约数个数

![image-20220430183607486](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220430183607486.png)

- 任意n的约数p都可以表示成$p = {p1^{a1} * p2^{a2}... *pk^{ak}}$其中

  - $a1 \in {\{0, 1, 2, ..., c1\}}$

  - $a2 \in {\{0, 1, 2, ..., c2\}}$

    ...

  - $ak \in {\{0, 1, 2, ..., ck\}}$

  取值组合总共有(c1 + 1)(c2 + 1)...(ck + 1)种



**模板**

```cpp
unordered_map<int, int> primes;     // 用哈希表保存质数的指数

// 质数分解
for (int i = 2; i <= x / i; i++)
    while(x % i == 0) {
        x /= i;
        primes[i]++;
    }
if (x > 1) primes[x]++;

// 约数个数定理
LL res = 1;
for (auto elem : primes) res = res * (elem.second + 1);
```



### 约数和

![image-20220430184952418](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220430184952418.png)

- 将括号拆开之后就是所有的约数相加

**模板**

```cpp
LL res = 1;
for (auto elem : primes) {
    int p = elem.first, a = elem.second;
    LL sum = 1;
    while(a--) sum = sum * p + 1; // sum * p + 1执行a 次就可以得到括号中的式子
    res *= sum;
}
```





### 最大公约数

使用欧几里得算法(辗转相除法)求最大公约数

- 设gcd(a, b)表示a, b的公约数

- 则有gcd(a, b) = gcd(b, a % b)

- 证明

  - 假设d为a, b的公约数, 即d | a, d | b, d | ax + by

  - a % b = a - c * b, 其中c = $\lfloor {{a} \over {b}} \rfloor$
  - 满足d | ax + by形式, 故d | a % b

**模板**

```cpp
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
```

- gcd(a, 0) = a
- 时间复杂度为log(n)



### 欧拉函数

![image-20220430200445493](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220430200445493.png)

**朴素做法**

```cpp
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1); // 不直接乘1 - 1/x, 防止误差

    return res;
}
```



**筛选法**

删选法的做法建立在使用线性筛选法求素数的基础之上

**模板**

```cpp
int primes[N], cnt;     // primes[]存储所有素数
int euler[N];           // 存储每个数的欧拉函数
bool st[N];             // st[x]存储x是否被筛掉（合数标记）


void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            // 质数
            primes[cnt ++ ] = i;
            euler[i] = i - 1;      // 如果一个数n是质数，那么1~n-1之间所有的数都与其互质
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)        
            {
                euler[t] = euler[i] * primes[j];      // !!
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);    // !!
        }
    }
}
```

- 在内层循环当中，使用pj表示primes[j], e[k] 表示k的欧拉函数值

  - i % pj == 0

    此时 `i` 与`pj * i` 的质因子是完全一样的，区别在于`pj * i`相对于 i来说质因子pj 的次数多了一次

    欧拉函数并不在乎质因子的次数，所有就可以得到**e[pj * i\] = pj * e[i]** 

  - i % pj != 0

    此时

    - i = p1 * p2 * ... * pk

    - pj * i = p1 * p2 * ... *pk * pj

    - e[i] = i * (1 - 1/ p1) * (1 - 1/ p2) *... *(1 - 1/pk)

    - e[pj * i] = pj * i *(1 - 1 / p1) * (1 - 1 / p2) * ... *(1 - 1 / pk) * (1 - 1 / pj)

      ​               = pj * e[i] *(1 - 1 / pj) 

      ​                = **(pj - 1) * e[i]**

    







### 快速幂

快速幂用途十分广泛，可以快速计算a^k^ % p

- 假设k的二进制表示为k = (10101)2, 那么则有
- $a^k = a^{2^0} * a^{2^2} * a^{2^{4}}$
- 对于任意一个a^k, 只需要求出$a^{2^0}, a^{2^1}, a^{2^2},a^{2^3} ..., a^{2^{logk}}$
- 就可以将这些数的部分积作为${a^k}$
- 这样做可以将求a^k的时间复杂度由$O(n)$降低至$O(logn)$

```cpp
typedef long long LL;
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL) res * a % p;      // 防止乘法溢出
        a = (LL) a * a % p;                    // 防止乘法溢出
        k >>= 1;
    }
    return res;
}
```

- 上面的做法并没有将a^t存起来，而是直接边算边使用



**例题**

- [acwing875](https://www.acwing.com/problem/content/877/)

