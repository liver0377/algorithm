### 题干

![image-20230105203111708](http://www.cdn.liver0377.xyz/typora/202301052031772.png)

![image-20230105203130976](http://www.cdn.liver0377.xyz/typora/202301052031087.png)



**解题思路**

- 将每个格子所在的竖线看做是一个宽度为1的水桶, 这个水桶的两边长度不一定相等

  ![image-20230105203414781](http://www.cdn.liver0377.xyz/typora/202301052034951.png)

- 该水桶的左边高度为: 左边所有格子的最高高度`h_l`

    右边高度为: 右边所有格子的最高高度`h_r`

- 该水桶所能够盛水的体积为`min(h_l, h_r)` - `height`

  其中`height`为下面黑色方格的高度

- 所以这里只需要求出所有前后缀的最大高度即可

  - `pre[i]`: 数组[0, i]的最大高度
  - `suf[i]`: 数组[i, n - 1]的最大高度

- 最终的答案就是$\Sigma(min(pre[i], suf[i]) - height[i])$

  

**代码实现**

- 时间复杂度: $O(N)$
- 空间复杂度: $O(N)$

```cc
class Solution {
public:
    int trap(vector<int>& height) {
        vector<int> pre(height.size());
        vector<int> suf(height.size());

        pre[0] = height[0];
        for (int i = 1; i < height.size(); i ++) {
            pre[i] = max(pre[i - 1], height[i]);
        }

        suf[height.size() - 1] = height.back();
        for (int i = height.size() - 2; i >= 0; i --) {
            suf[i] = max(suf[i + 1], height[i]);
        }

        int ans = 0;
        for (int i = 0; i < height.size(); i ++) {
            int t = min(pre[i], suf[i]) - height[i];
            ans += t;
        }

        return ans;
    }
};
```

