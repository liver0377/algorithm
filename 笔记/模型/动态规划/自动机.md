**题干**

![image-20220528205421003](http://www.cdn.liver0377.xyz/typora/202205282054073.png)

![image-20220528205433314](http://www.cdn.liver0377.xyz/typora/202205282054355.png)





**解题思路**

- 采用状态机来进行求解

- 设s为文本串，即密码, t为给定的子串， 即模式串

- 从前向后一位一位的确定密码，选出那些合法的方案

- 状态表示

  $f[i][j]$表示已经确定的密码位数为I位，后缀长度为j的子串与给定的模式串匹配, 属性为对应的选法的方案数

  - 例
    - 密码 : xxxxab
    - 模式串: abc
    - 则$f[6][2]$ 为密码 `xxxxab` 可选的方案数

- 状态计算

  通过例子来讲解状态计算

  - 密码s : xxxca**b**_，\_表示这一位会被用于枚举, 从'a'到'z'

  - 模式串t: _cab**c**xxx, _表示哨兵位

  - i == 6, j == 3, j总是表示当前匹配长度

  - $s[i] == \_, t[j + 1] == c$

  - 使用KMP找到密码串与当前模式串匹配的最后一位u

    - 情况1，不需要跳转，这里令密码串中的_ == c

      - 即, 密码s: xxxbcb**c**
      - 模式串  t: _bcb**c**xxx 

      这样就可以直接由当前状态$f[i][j]$确定$f[i + 1][j]$

      具体的：

      - $f[7][4] += f[6][3]$

        > 如何理解上述转化关系？
        >
        > 当前已经确定了6位密码，密码后面3位与模式串匹配的方案数，$f[6][3]$
        >
        > 枚举第7位为'c',又与模式串发生匹配，因此从$f[6][3]$再走一步，即将第7位置为'c', 就可以到达$f[7][4]$
        >
        > 因此有$f[7][4] += f[6][3]$

    - 情况2，需要KMP跳转, 这里令密码串中的_ == d

      - 即，密码s: xxxbcb**d**
      - 模式串    t: _bcb**c**xxx

      - 经过KMP跳转之后，令u为j跳转到的新位置

      - u == 2,  t[u] == c

      - 此时有$f[7][2] += f[6][3]$, 这里的2就是u的值，即新匹配的子串"bc"的长度

        - s:   xxx**bc**bd
        - t:  _**bc**bcxxx

        > 如何立即上述转化？
        >
        > 当前已经确定了6位密码，密码后面3位与模式串匹配的方案数，$f[6][3]$
        >
        > 枚举第7位为'd', 此时密码与模式串只有2位发生了匹配，即我们又经过一步操作，即将第7位置为'd', 到达了
        >
        > $f7][2]$
        >
        > 因此有$f[7][2] += f[6][3]$

- 一般的，有状态转移方程

  - $f[i + 1][u] = f[i + 1][u] + f[i][j]$, u为新的**密码后缀与模式串匹配的长度**

- 如果采用状态机模型的话，可能类似于这样，下面这张图并不代表之前给出的例子

  ![image-20220528214247290](http://www.cdn.liver0377.xyz/typora/202205282142347.png)

  - 每个点代表一个匹配长度，最终的答案也就是所有匹配长度在0~m - 1内密码方案和，m为模式串的长度，即$\sum_{i = 0} ^ {m - 1}{f[n][i]}$
  - 如果匹配长度为m的话，那么就代表密码包含了模式串



**题解**

```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 55, mod = 1e9 + 7;

int n, m;
char s[N];
int f[N][N], ne[N];

int main()
{
    cin >> n >> s + 1;
    m = strlen(s + 1);
    //KMP预处理前缀表
    for (int i = 2, j = 0; i <= m; ++ i)
    {
        while (j && s[i] != s[j + 1]) j = ne[j];
        if (s[i] == s[j + 1]) ++ j;
        ne[i] = j;
    }
    //DP
    f[0][0] = 1;
    for (int i = 0; i < n; ++ i)
    {
        for (int j = 0; j < m; ++ j)  
            // 这里的条件很关键, j < m 确保了结果满足下列性质
            // 1. 首先f[n][k]，表示密码长度为n, 密码后缀有k个字符与模式串匹配
            //    思考这个问题: 虽然密码的最后m个字符一定不与模式串匹配，但是在最后m个字符前面呢，即在0 ~ n - m
            //    密码子串内，是否包含模式串呢？
            // 2. 结果是：不包含
            // 采用反证法，假设在s[0 ~ n -m]内包含模式串，考虑状态机模型, 则必然有f[k][m] > 0， 即长度为k的密码后面的             // m个字符与模式串发生匹配
            // 由递推方程 f[i + 1][u] = f[i + 1][u] + f[i][j], 这里 u == m, j < m
            // 我们的答案res = f[n][0] + f[n][1] +... + f[n][m - 1]
            // 对于任意一项f[n][t], 都不会从f[k][m]递推而来, 因此答案是正确的
        {
            for (char ch = 'a'; ch <= 'z'; ++ ch)   //枚举第i+1个字符
            {
                int u = j;    //计算枚举到第i+1个字符后，后缀匹配的最大长度
                while (u && s[u + 1] != ch) u = ne[u];
                if (s[u + 1] == ch) ++ u;
                f[i + 1][u] = (f[i + 1][u] + f[i][j]) % mod;    //更新i+1的状态
            }
        }
    }
    //统计所有目标状态
    int res = 0;
    for (int j = 0; j < m; ++ j) res = (res + f[n][j]) % mod;
    cout << res << endl;
    return 0;
}
```

