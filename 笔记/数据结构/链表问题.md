### 链表反转

链表反转有三种方式

**prev, cur同步向前**

- 定义两个指针： pre 和 cur, pre 在前 cur 在后
- 每次让 pre 的 next 指向 cur ，实现一次局部反转
- 局部反转完成之后，pre 和 cur 同时往前移动一个位置
- 循环上述过程，直至 pre 到达链表尾部

![img](https://pic.leetcode-cn.com/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif)

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* cur = NULL, *pre = head;
        while (pre != NULL) {
            ListNode* t = pre->next;
            pre->next = cur;
            cur = pre;
            pre = t;
        }
        return cur;
    }
};
```



**递归**

- 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 ret
- 此后，每次函数在返回的过程中，让当前结点的下一个结点的 nextnext 指针指向当前节点。
- 同时让当前结点的 next 指针指向 NULL ，从而实现从链表尾部开始的局部反转
- 当递归函数全部出栈后，链表反转完成

![img](https://pic.leetcode-cn.com/8951bc3b8b7eb4da2a46063c1bb96932e7a69910c0a93d973bd8aa5517e59fc8.gif)

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == NULL || head->next == NULL) {
            return head;
        }
        ListNode* ret = reverseList(head->next);
        head->next->next = head;
        head->next = NULL;
        return ret;
    }
};
```



**双指针**

![img](https://pic.leetcode-cn.com/1c8927d9ff605502793d81ab344dbc17e16d6db2d8dd789045f56af432079519.gif)

```cpp
ListNode* reverseList(ListNode* head) {
        if (!head) return head;
        ListNode *h = new ListNode(-1, head);
        ListNode *prev = h;
        ListNode *cur = head;
        while(cur->next) {
            ListNode *t = cur->next;
            cur->next = t->next;
            t->next = prev->next;
            prev->next = t;
        }
        return h->next;
}
```

> 当使用局部链表的翻转时，使用该方法比较合适





### 链表的环

**判断是否有环**

- 龟兔赛跑算法可以用于确定一个链表中是否存在环

- 使用`slow, fast`两个指针, 初始时令它们都指向链表首位置
- 令`fast`每次移动两步, `slow`每次移动一步
- 如果链表中有环, 则`fast`指针一定会追上`slow`指针
- 如果遇到了空节点, 那么肯定没有环

```cpp
 bool hasCycle(ListNode *head) {
        if (!head || !head->next) {
            return false;
        }

        ListNode *slow = head;
        ListNode *fast = head;
        while (true) {
            if (!fast || !fast->next){
                return false;
            }
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow) break ;
        }
        return true;
}
```



**判断环的起始点**

使用以下流程判断环的起点

- 设置`slow, fast`两个指针, 初始值, 令它们都指向链表首部
- 依旧采用龟兔赛跑方法, 令`fast`指针每次移动两步, `slow`指针每次移动一步
- 当两指针第一次相遇时, `slow`保持不变, 令`fast`指向链表的头部
- 当两指针再次相遇时, 相遇点即为环的起点



- 证明

  - 记`a`为起始点到环首位置的距离, `b`为环的长度

  - 当两个节点第一次相遇时, 记`s`为`slow`指针距离链表首部移动的距离, 记`f`为`fast`指针距离链表指针移动的距离

    则有

    - $f - s = k * b$
    - $f = 2 * s$

    根据上式可以推导出

    $s = n * b, f = 2 * n * b$

    即快指针比慢指针多跑了几个环

  - 此时将`fast`指针置于链表首部, `slow`置于链表尾部

  - 当经过`a`次移动之后, $s = n * b + a, f = a$

    此时它们正好都位于环的起始点, 即第二次相遇



- 模板

  ```cc
  ListNode *detectCycle(ListNode *head) {
          ListNode *f = head, *s = head;
          
          while (true) {
              if (!f || !f->next) return nullptr;
              f = f->next->next;
              s = s->next;
              if (f == s) break ;
          }
          f = head;
          while (true) {
              if (f == s) break;
              f = f->next;
              s = s->next;
          }
          return f;
      }
  ```






### 链表的中间节点

给定一个头结点为 `head` 的非空单链表，返回链表的中间结点

如果有两个中间结点，则返回第二个中间结点



- 使用快慢指针求解

- 快指针每次走两步, 慢指针每次走一步, 当快指针走到终点时,  慢指针所指的位置就是中间节点

- 根据链表长度的奇偶性, 需要进行分类讨论

  - 链表的长度为奇数

    ![image-20221209201041158](D:/Typora/pics/image-20221209201041158.png)

    此时`f`走到最后一个非空节点即可

  - 链表长度为偶数

    ![image-20221209201122767](D:/Typora/pics/image-20221209201122767.png)

    此时`f`需要走到最后的空节点

  综合考虑以上两种情况, 当`f`发现`next`或者`next.next`为空时, 即可以退出



- 模板

  ```cc
  ListNode* middleNode(ListNode* head) {
          ListNode *fast = head, *slow = head;
  
          while (fast && fast->next) {
              fast = fast->next;
              fast = fast->next;
              slow = slow->next;
          }
  
          return slow;
      }
  ```

  



