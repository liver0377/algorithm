

### 水果成篮

![image-20221017082621042](http://www.cdn.liver0377.xyz/typora/202210170826126.png)

![image-20221017082645256](http://www.cdn.liver0377.xyz/typora/202210170826302.png)



**解题思路**

- 此题基于滑动窗口

- 设窗口`[i, j)`表示以`j`结尾的**最大**合法窗口, 最大合法窗口要求**窗口内部的元素种类不超过2**

- 下面证明一个结论

  - 若`[i, j)`合法时, 若`[i, j')`也合法, 那么`i`一定是以`j'`结尾的最大合法窗口的左端点

  证明:

  - 假设`i`不是以`j'`结尾的最大合法窗口的左端点, 那么存在`i' < i`, 使得`[i', j')`合法
  -  但是`[i', j)`肯定是非法窗口, 因为`[i, j)`是以`j`结尾的最大合法窗口, `[i',j)`必然会包含三种及以上的水果种类
  - 由于`[i', j)`是`[i', j')`的子数组, 所以`[i', j')`肯定也非法
  - 即不存在`i' < i`, 使得`[i', j)`合法

- 根据上述结论, 按照以下流程滑动窗口

  - 当前窗口`[i, j)`合法时, 使用`j - i`尝试更新全局最大解, 因为`j - i`此时就是以`j - 1`结尾的最大合法窗口的长度
  - 右移`j`
  - 若此时窗口非法, 则不断右移`i`, 直到`[i, j)`合法为止, 使用`j - i`尝试更新全局最大解

  

**代码实现**

- 时间复杂度: $O(N)$
- 空间复杂度: $O(1)$

```cc
class Solution {
public:
    int totalFruit(vector<int>& v) {
        int n = v.size(), kind = 0;

        int res = 0;
        unordered_map<int, int> mp;  // 统计窗口内部的不同种类的果子的出现次数, 最大只有3个元素
        for (int i = 0, j = 0; j < n;) {
            int t = v[j];
            j ++;
            if (!mp[t]) {
                kind ++;
            }
            mp[t] ++;


            while (i <= j && kind > 2) {
                int t = v[i];
                i ++;
                if (-- mp[t] == 0) kind --;
            }
            
            // printf("[%d, %d)\n", i, j);
            res = max(res, j - i);
        }

        return res;
    }
};
```

