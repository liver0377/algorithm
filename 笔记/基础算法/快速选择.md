**基本思想**

快速选择算法是对快速排序的改进，适用于想找到一个无序数组中的第k个小的数的情况

- 寻找分界点x, 将数组分成两段，左边均<=x, 右边均 >=x

  与快速排序一样

- 分情况讨论, 设数组左边的元素个数为sl

  - k <= sl

    此时第k小的元素一定在数组左边，递归左边

  - k > sl

    此时第k小的元素一定在数组右边，并且在右边的数组中，排第k - sl小, 递归右边



### 简单模板

**模板**

- 平均时间复杂度: $O(N * log(N))$, 最差情况下会到 $O(N ^ 2)$

```c
#include <iostream>
using namespace std;

int n;
int k;
const int N = 1e6;
int q[N];


int quick_sort(int l, int r, int k) {
    if (l >= r) return q[l];
    
    int i = l - 1, j = r + 1, x = q[l];
    while (i < j) {
        while (q[ ++i] < x);
        while (q[ --j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    
    int sl = j - l + 1;
    if (k <= sl) {
        return quick_sort(l, j, k);
    } else {
        return quick_sort(j + 1, r, k - sl);
    }
}

int main() {
    cin >> n >> k;
    for (int i = 0; i < n; i++) cin >> q[i];
    cout << quick_sort(0, n - 1, k);
}
```





### 随机选择轴值

该种方法在`leetcode`上广为使用, 相对于`y`总的写法而言,  **随机选择了轴值**, **递归层数也减小了**



- 时间复杂度 : $O(N)$

```cc
vector<int> nums(n);

// 将数组中小于轴值的元素全部置于左侧, 大于轴值的元素全部置于右侧
// 返回轴值下标
int partition(int left, int right, int pivot_index) {
    int pivot = nums[pivot_index];
    swap(nums[pivot_index], nums[right]); // 将轴值与最后一个元素交换, 便于接下来的比较
    int store_index = left;
    
    for (int i = left; i <= right; i ++) {
        if (nums[i] < pivot) {
            swap(nums[store_index], nums[i]);
            store_index ++;
        }
    }
    swap(nums[store_index], nums[right]);   // 此时store_index左边的元素全部小于轴值, 自身大于轴值, 将轴值换回来
    
    return store_index; 
}

// 返回整个nums数组的第k小值
// [left, right]为当前正在递归的区间
int quick_select(int left, int right, int k) {
    if (left == right) return nums[left];
    
    int pivot_index = rand() % (right - left + 1) + left;
    pivot_index = partition(left, right, pivot_index);
    
    if (k == pivot_index) {
        return nums[k];
    } else if (k < pivot_index) {
        return quick_select(left, pivot_index - 1, k);
    } 
    return quick_select(pivot_index + 1, right, k);
}


quick_select(0, sz - 1, k);
```

