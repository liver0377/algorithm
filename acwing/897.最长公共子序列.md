### 最长公共子序列

**题干**

![image-20220525134341081](http://www.cdn.liver0377.xyz/typora/202205251343153.png)

**解题思路**

- 状态转移方程

  f[i\][j\]表示a[1\~i]与b[1~j]的最长公共子序列，注意这里没有要求a[i]或者b[j]必须在子序列中

- 子集划分

  首先划分四个子集

  1. $a[i],b[j]$均不在子序列中
  2. $a[i]$在子序列中,$b[j]$不在子序列中
  3. $a[i]$不在子序列中, $b[j]$在子序列中
  4. $a[i],b[j]$均在子序列中

  然后列出以下四个状态:

  $f[i - 1][j - 1], f[i - 1][j], f[i][j - 1],f[i - 1][j - 1] + 1$

  然而，实际上上面这些状态与之前划分的子集并不是完全对应的，之前划分的子集无法精确的表示出来，但是，**上面的状态对应的集合的并集可以包含所有的情况**

  - $f[i - 1][j]$表示$a[i]$不在结尾，但是$b[j]$可能在，也可能不在的子序列集合, 即1, 3
  - $f[i][j - 1]$表示$b[j]$不在结尾，但是$a[i]$可能在，也可能不在的子序列集合, 即1, 2
  - $f[i - 1][j - 1]$表示$a[i], b[j]$均不在子序列结尾, 即1, 很明显被上面两种状态包含了, 可以不使用
  - $f[i - 1][j - 1] + 1$表示$a[i], b[j]$在子序列, 即4

  这几个状态包含了所有的状态集合

  > 由于这里求的是子集的最大长度，所有划分的子集可以有重叠，但是如果求得是个数之类的，就不能够重叠
  
  

**题解**

```cpp
#include <iostream>
 #include <algorithm>

using namespace std;

const int N = 1010;
int n, m;
char a[N], b[N];
int f[N][N];


int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int j = 1; j <= m; j++) cin >> b[j];
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            f[i][j] = max({f[i - 1][j - 1] + (a[i] == b[j]), f[i - 1][j], f[i][j - 1]});
        }
    }
    
    cout << f[n][m] << endl;
    return 0;
}
```

