![image-20220619163328647](http://www.cdn.liver0377.xyz/typora/202206191633737.png)



- 状态表示

  ![image-20220619163654284](http://www.cdn.liver0377.xyz/typora/202206191636323.png)

- 状态计算
  $f[i][j][a] = f[i - 1][j - cnt[a]][b1] + f[i - 1][j - cnt[a]][b2] + ...$



- 解题思路
  - 这里的解题思路和蒙德里安的梦想比较相似，使用状态压缩的方式进行求解
  - 由于国王只会攻击周围8个格子，如果自上向下遍历整个棋盘，那么第i行的状态只与第i - 1行的状态有关
  - 什么样的状态是合法的?
    - 该行的状态不能够有连续个1
    - 该行不能够与前一行发生冲突，设前一行状态为b, 当前行状态为a, 若a与b不发生冲突，则有
      - (a & b)== 0
      - a | b不能够有连续个1

**代码**

```cpp
#include <cstring>
#include <iostream>
#include <vector>

using namespace std;

const int N = 12;
const int M = 1 << 10;
const int K = N * N;

typedef long long LL;
int n, m;               // n: 棋盘阶数, m:旗子个数
LL f[N][K][M];          // f[i][j][s]: 第i行, 使用了j个旗子，状态为s的方案数
int cnt[M];             // cnt[i]: 状态i对应的1的个数
vector<int> state;      // 存储所有合法状态
vector<int> trans[M];   // trans[i]: 可以转移到状态i的所有状态

// 检查某个状态是否有连续个1
bool check(int state) {
    return !(state & state >> 1);
}

// 判断某个状态中'1'的数目
int count(int state) {
    int res = 0;
    for (int i = 0; i < n; i++) {
        if (state >> i & 1) {
            res ++;
        }
    }
    return res;
}

int main() {
    cin >> n >> m;
    // 1. 筛选出所有合法状态
    for (int s = 0; s < 1 << n; s ++) {
        if (check(s)) {
            state.push_back(s);
            cnt[s] = count(s);
        }
    }
    
    // 2. 预处理出所有状态的可能的转移到的状态
    for (int i = 0; i < state.size(); i++) {
        for (int j = 0; j < state.size(); j++) {
            int a = state[i];
            int b = state[j];
            // (1) 新状态 & 旧状态 == 0
            // (2) 新状态 | 旧状态 不包含连续个1 
            if (!(a & b) && check(a | b)) {
                trans[a].push_back(b);
            }
        }
    }
    
    f[0][0][0] = 1; // 0行不存在，可以看成是一个国王都不放置，方案数为1
    for (int i = 1; i <= n + 1; i++) {  // 多算一行，便于最后输出答案
        for (int j = 0; j <= m; j++) {
            for (auto& a : state) { // 新状态
                for (auto& b : trans[a]) { // 旧状态
                    int t = cnt[a];
                    
                    // 若第i行状态为a, 那么至少已经放置了t个棋子, 筛掉j < t 的不合法方案
                    if (j >= t) {
                        f[i][j][a] += f[i - 1][j - t][b];
                    }
                }
            }
        }
    }
    
    // 从前n + 1行放，第n + 1行状态为0，与从前n行放，第n行为所有可行状态的方案数是一样的
    cout << f[n + 1][m][0] << endl;
    return 0;
}
```

- 这里采用了一些预处理操作，首先选出了所有的合法状态，然后存储了每个状态的所有转移情况

- 时间复杂度
  这里采用了预处理的方式，而没有使用直接枚举的方式，目的就是为了降低时间复杂度

  - 直接枚举: $O(n^3m2^n2^n)$

  - 预处理: $O(n^3m * s1 * s2)$

    s1为所有合法方案，s2为可以转移到s1的合法方案，s1 * s2的大概范围在$10^3$左右

