### 线段树

- 定义

  线段树是一种二叉树，其满足如下性质：

  1. 线段树的每一个节点都代表一个区间

  2. 线段树具有唯一的根节点，代表的是整个区间

  3. 线段树的每个叶子节点都代表一个长度为1的区间

  4. 对于每个内部节点[l, r]，它的左子节点代表区间为[l, mid], 右子节点代表区间为[mid + 1, r]

     mid = (l + r) / 2下取整



- 图例

  ![image-20220905180740415](http://www.cdn.liver0377.xyz/typora/202209051807497.png)



- 存储

  对于一棵线段树，除了最后一层之外，其它节点构成了一棵**满二叉树**， 树的深度为$O(log(N))$

  通常对节点采取下面的编号方式：

  - 根节点编号为1
  - 编号为`x`的节点的左子节点编号为`2 * x`, 右子节点编号为`2 * x + 1`

  可以直接按照编号将整个线段树存储在数组当中，假设给定区间长度为`N`, 那么该区间对应的线段树的叶子节点数目为`N`, 

  若是在满二叉树中，节点的数目应该为`2 * N  - 1`, 但是由于线段树的最后一层有空缺，而最后一层的元素数目最多为`2 * N`

  因此，**线段树数组的长度应该不小4 * N**

  - 例

    ```cc
    struct SegmentTree {
        int l, r;
        int dat;   // dat表示[l, r]区间内的最大值, 在实际使用中，这里的含义可以变换
                   // 该属性必须得满足，dat能够有两个子节点的dat递推出来
    } t[N * 4];
    ```

- 初始化

  下面给出建立一棵二叉树的模板

  ```cc
  // 构建根节点编号为p, 节点所代表区间为[l, r]的子树
  void build(int p, int l, int r) {
      t[p].l = l, t[p].r = r;
      if (l == r) { 
          t[p].dat = a[l];
          return;
      }
      int mid = l + r >> 1;
      build(p * 2, l, mid);
      build(p * 2 + 1, mid + 1, r);
      t[p].dat = max(t[p * 2].dat, t[p * 2 + 1].dat);
  }
  ```

  - 使用

    ```cc
    build(1, l, r);
    ```

    

- 查询

  这里的查询指的是对某一个区间进行查询，下面给出模板

  ```cc
  // 设根节点为p的子树锁代表的区间为[pl, pr]
  // 该函数返回[pl, pr]与[l, r]重叠部分的最大值
  int query(int p, int l, int r) {
      if (l <= t[p].l && r >= t[p].r) return t[p].dat;
      int mid = (t[p].l + t[p].r) / 2;
      int val = -(1 << 30);
      if (l <= mid) val = max(val, query(p * 2, l, r))  
      if (r > mid) val = max(val, query(p * 2 + 1, l, r)); 
      return val;
  }
  ```

  - 可以证明得出，查询节点的最多数目为$O(4 * log(N))$, 因此，时间复杂度为$O(log(N))$

  上面给出的查询步骤遵循这些过程:

  ![image-20220905183611441](http://www.cdn.liver0377.xyz/typora/202209051836502.png)

  - 使用

    ```cc
    query(1, l, r);
    ```

    

- 单点修改

  单点修改通常是指将`a[x]`改为`v`, 下面给出模板

  - 时间复杂度: $O(log(n))$

  ```cc
  // 将根节点为P的子树内部，下标为x的值改为v, 同时维护整个线段树的正确性
  void modify(int p, int x, int v) {
      if (t[p].l == t[p].r) {
          t[p].dat = v;
          return ;
      }
      int mid = l + r >> 1;
      if (x <= mid) modify(p * 2, x, v);
      else modify(p * 2 + 1, x, v);
      t[p].dat = max(t[p * 2].dat, t[p * 2 + 1].dat);  // y总常常将该行写成pushup函数
  }
  ```

  