### 灯泡开关

![image-20220915113232545](http://www.cdn.liver0377.xyz/typora/202209151132622.png)



**解题思路**

- 这里需要考虑到周期性

- 开关1只会影响编号为1的倍数的灯泡, 开关2只会影响编号为2的倍数的灯泡, 开挂三只会影响奇数编号的灯泡, 开关四只会影响3k + 1的灯泡

- 如果使用状态1表示灯泡打开, 0表示灯泡未打开, 将所有灯泡排成一排, 那么经过任意次操作之后, 灯泡的状态以6个灯泡为周期

  也就是说, 每6个灯泡的状态都和前6个灯泡的状态一模一样, 因此状态空间可以缩小到前6个灯泡

- 对于4个开关而言, 任意一个开关操作偶数次都等于没有操作, 那么,对于一个开关的操作, 只有偶数次和奇数次的区别

- 同样也可以使用状态位表示每个开关的开闭状态, 状态空间最大只有2^4,可以直接枚举



- 流程

  - 枚举开关的2^4种状态
  - 对于每种状态, 判断`presses`次操作能否到达该状态 , 即`sum % 2 == presses % 2 && presses >= sum`, `sum`为有多少个开关处于打开状态

  - 如果能够到达该状态, 我们就把该状态的影响作用到灯泡状态位上, 灯泡状态只需要记录6位即可, 具体来说
    - 开关1将灯泡的状态位0, 1, 2, 3, 4, 5全部取反, 即^63
    - 开关2将灯泡的状态位0, 2, 4, 6全部取反, 即^ 42
    - 开关3将灯泡的状态位1, 3, 5全部取反, 即^21
    - 开关4将灯泡的状态位1, 4全部取反, 即^9
  - 将所有得到的灯泡状态放入`set`去重计数即可

> 注意灯泡数量`n`少于6的情况, 此时只需要取得到的状态的最后`n`位即可



**代码实现**

- 时间复杂度: $O(1)$

```cc
class Solution {
public:
    int flipLights(int n, int presses) {
        const int flip[4] = {63, 42, 21, 9}; 
        unordered_set<int> st;
        for (int i = 0; i < 1 << 4; i++) {
            int cur_sta = i, sum = 0;
            for (int j = 0; j < 4; j++) {
                if (i >> j & 1) sum ++;
            } 
 
            if (sum % 2 == presses % 2 && presses >= sum) {
                // 可以走到cur_sta
                int sta = 0;
                for (int k = 0; k < 4; k++) {
                    if (cur_sta >> k & 1) {
                        sta ^= flip[k];
                    }
                }
                if (n < 6) sta &= (1 << n) - 1;
                st.insert(sta);
            }
        }
        return st.size();
    }
};
```

