![image-20220415204505127](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220415204505127.png)



**存储方式**

这里依旧使用数组来存储

![image-20220415211824748](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220415211824748.png)

**down 与 up**

down和up操作分别代表向下调整堆以及向上调整堆，以小根堆为例

- 当一个节点的元素变大时，应该尝试进行down操作，将其与左右孩子中较小的元素进行交换，然后继续向下调整

- 当一个节点的元素变小时，应该尝试进行up操作，将其换上去

- 注意到在上图中的步骤4, 5当中，down(k)和up(k)都写了，但其实只要一个会被真正的执行，这样做只是为了方便而已

  

**快速建堆**

只需要使用一行代码就可以快速建堆

```cpp
for (int i = n / 2; i; i --) down(i);
```

即从 n / 2 处开始将所有前面的节点全部`down()`一遍，时间复杂度为O(n)

- n / 2 是最后一个具有孩子的子树，因此从它开始

- 时间复杂度的求法

  假设有n个节点构成如下的堆，那么倒数第二层就有 n / 4个节点, 它们要向下`down`一层, 倒数第三层有 n / 8 个节点，它们要向下`down`两层

  ![image-20220415205630100](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220415205630100.png)

  最终的时间复杂度为 n / 4 * 1 + n / 8 * 2 + ... = O(n)





**模板**

```cpp
// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
int h[N], size;}

void down(int u)
{
    int t = u;
    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;  // 找到左右孩子中的最小节点
    if (u != t)
    {
        swap(u, t);                                               // 交换根节点与孩子节点，然后向下递归进行down
        down(t);
    }
}

void up(int u)
{
    while (u / 2 && h[u] < h[u / 2])                             // 如果父节点比当前节点大，那么进行交换
    {
        swap(u, u / 2);
        u /= 2;
    }
}
// --------------------------------基本操作--------------------------------
// 0. 建堆
void init() {
    for (int i = n / 2; i; i -- ) down(i);
}

// 1. 插入一个数
void insert(int x) {
    h[++size] = x;
    up[size];  
}

// 2. 求最小值
int top() {
    return h[1];
}

// 3. 删除最小值
void remove() {
    h[1] = h[size];
    size--;
    down(1);
}

// 4. 删除任意位置的元素（STL没有）
void remove(int k) {
    h[k] = h[size];
    size--;
    down(k);
    up(k);
}

// 5. 修改任意位置的元素（STL没有）
void update(int k, int x) {
    h[k] = x;
    down(k);
    up(k);
}


```



**带映射的堆**

可以看一下[acwing839题解](https://www.acwing.com/problem/content/841/)

**例题**

- [acwing838](https://www.acwing.com/problem/content/840/)

- [acwing839](https://www.acwing.com/problem/content/841/)

  

