**题干**

![image-20220422105159376](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220422105159376.png)

![image-20220422105211262](https://cdn.jsdelivr.net/gh/liver0377/images@main/img/image-20220422105211262.png)



**题解**

这里的解题思路是采用DFS，并且在进行递归的过程中进行剪枝操作

- 逐行进行扫描，枚举所有可能的列
- 如果该列，该对角线，该反对角线上没有放置旗子，那么该位置上就可以放置皇后，否则，这个分支就不符合要求，应该被剪去



```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 20;            // 这里N的大小开到了2倍，因为(反)对角线的条数为2 * n - 1
char g[N][N];                // 棋盘，这里的行列下标均是从0开始的
int col[N], dg[N], udg[N];   // dg[i]表示截距为i的对角线上是否有旗子，udg[i]表示截距为i的反对角线上是否有旗子
                             // 由于行列下标均可以为0，因此可能存在截距为0的这种情况
                             // col[i]表示第i列上是否有旗子
int n;

void dfs(int u) {
    if (u == n) {
        for (int i = 0; i < n; i++) puts(g[i]);
        puts("");
        return;
    }
    
    for (int i = 0; i < n; i++) {  // 列从0开始
        if (!col[i] && !dg[u + i] && !udg[n + i - u]) {   // 这里的n + i - u之所以要加上n是因为 i - u 可能会出                                                           // 现负数, 最小的n + i -  u正好是0
            col[i] = dg[u + i] = udg[n + i - u]= true;
            g[u][i] = 'Q';
            dfs(u + 1);
            col[i] = dg[u + i] = udg[n + i - u]= false;
            g[u][i] = '.';
        }
    }
}

int main() {
    cin >> n;
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            g[i][j] = '.';
        }
    }
    
    dfs(0);
    
    return 0;
}
```

