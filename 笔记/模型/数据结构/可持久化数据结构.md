### 可持久化Trie树

可持久化`Trie`树维护了多个版本的`Trie`树，但是不同版本的`Trie`树之间，最大可能地复用节点

- 例: 分别插入cat, rat, cab, fry

![image-20220909210225680](http://www.cdn.liver0377.xyz/typora/202209092102748.png)



- 每当要创建一个新版本`Trie`树时，只需要开创当前字符串长度的节点即可

- 同时，利用指针指向之前版本的非重复节点，就可以从新版本的根节点得到一棵新的`Trie`树

- 如何添加指针?

  - 开创新根节点

    ![image-20220909210739448](http://www.cdn.liver0377.xyz/typora/202209092107484.png)

    上图中，下一个要添加的点是`r`, 查看上一版本的第二层，发现没有`r`节点，因此上一版本的该路径全部可以复用

    ![image-20220909211126488](http://www.cdn.liver0377.xyz/typora/202209092111526.png)

    接下来依次添加新节点即可

    ![image-20220909211309286](http://www.cdn.liver0377.xyz/typora/202209092113316.png)

  - 如果发现上个版本的同层节点与新添加的节点相同，由于自身这个新节点肯定要建立，因此就不需要复用旧版本的节点了

    ![image-20220909211800836](http://www.cdn.liver0377.xyz/typora/202209092118934.png)

    第二个版本的第二层，有`c`节点，与第三个版本新添加的`c`重复，因此不进行复用，但是后面的`t`节点不同，依旧要进行复用

  > 可以看出，一条“笔直向下”路径最多只会与上一版本的其它“笔直向下”路径连接一条边





**代码模板**

这里以[最大异或和](https://www.acwing.com/problem/content/258/)为例给出模板

```cc
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

typedef long long LL;
const int N = 1e5 * 30 + 10;

int son[N][2], num;
int a[N], n;

void insert(int x) {
    int p = 0;
    for (int i = 30; i >= 0; i --) {
        int t = x >> i & 1;
        if (!son[p][t]) son[p][t] = ++ num;
        p = son[p][t];        
    }
}

LL search(int x) {
   int p = 0;
   LL ans = 0;
   for (int i = 30; i >= 0; i --) {
       int t = x >> i & 1;
       if (son[p][!t]) {
           ans = ans << 1 | 1;
           p = son[p][!t];
       } else {
           ans = ans << 1 | 0;
           p = son[p][t];
       }
   }
   return ans;
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
        insert(a[i]);
    }
    LL res = 0;
    for (int i = 0; i < n; i++) res = max(res, search(a[i]));
    
    cout << res << endl;
    return 0;
}
```

