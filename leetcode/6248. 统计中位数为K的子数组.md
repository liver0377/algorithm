### 统计中位数为K的子数组



![image-20221127172059067](http://www.cdn.liver0377.xyz/typora/202211271722906.png)

![image-20221127172219054](http://www.cdn.liver0377.xyz/typora/202211271722369.png)

**解题思路**

- 题目中给定的中位数的定义与普通的中位数定义**不同**

  都能够数组长度为偶数时, 这里的中位数被定义为中间靠左的元素

- 由于`k < n`, 并且该数组是1 ~ n的排列, 因此`k`一定是数组中的一个元素

- 首先可以找到`k`在数组中的位置, 其将数组一分为二

- 假设子数组长度为奇数

  ![image-20221127172519845](http://www.cdn.liver0377.xyz/typora/202211271725885.png)

  这里[2, 7, 4, 3, 5]的中位数为4, 并且长度为奇数

  - 位于4左侧小于4的元素个数 + 位于4右侧小于4的元素个数 = 位于4左侧大于4的元素个数 + 位于4右侧大于4的元素个数

  - 将上面的四个值分别标记为$(1), (2), (3), (4)$

  - 则转换之后可得$(1) - (3) = (4) - (2)$

  - 因此, 可以分别遍历中位数的右边和左边, 不断计算累计和

    - 位于中位数右边且大于中位数的元素为1, 小于中位数的元素为-1
    - 位于中位数左边且小于中位数的元素为1, 大于中位数元素为-1

  - 最终的效果如下

    ![image-20221127173129736](http://www.cdn.liver0377.xyz/typora/202211271731619.png)

    > 上图中, 下面的数字为累计和, 如3占-1分, 5占1分, 因此到5的累计和就变为了0

  - 为什么要计算累计和, 这是因为最终要求的是子数组, 如果选择了更远端的元素`x`, 那么`x`内侧的元素必然要全部选择

  - 对于一个以`k`为中位数的奇数子数组而言, 其左右两侧的数字一定得是匹配的

  - 因此[2 ~ 5], [7 ~ 3], [0]都是合法的奇数子数组

- 对于长度为偶数的子数组而言, 公式要稍微发生一下变化

- $(1) - (3) + 1 = (4) - (2)$

  ![image-20221127173605574](http://www.cdn.liver0377.xyz/typora/202211271736229.png)

  

- 最终流程

  - 首先找到中位数`k`的位置
  - 然后遍历其右边的所有元素, 计算他们的累计和, 同时使用一个哈希表记录下各个累计和的出现次数
  - 然后遍历中位数左边的所有元素, 对于左边的任意一个累计和`sum`, 其可以和右边的累计和`sum`(奇数), `sum + 1`(偶数)匹配

  - 每个匹配就是一个合法子数组



**代码实现**

```cc
class Solution {
public:
    int countSubarrays(vector<int>& nums, int k) {
        unordered_map<int, int> mp;
        auto idx = find(nums.begin(), nums.end(), k) - nums.begin();

        int sum = 0;
        mp[0] = 1;
        for (int i = idx + 1; i < nums.size(); i ++) {
            sum += nums[i] > k ? 1 : -1;
            mp[sum] ++;  
        }

        int res = mp[0] + mp[1];
        sum = 0;
        for (int i = idx - 1; i >= 0; i --) {
            sum += nums[i] < k ? 1 : -1;
            res += mp[sum] + mp[sum + 1];
        }

        return res;
    }
};
```

