

### 下一个排列

![image-20221017153601511](http://www.cdn.liver0377.xyz/typora/202210171536569.png)



**解题思路**

- 对于一个给定的数组而言, 如果想要获取一个比它大的排列, 那么肯定要将后面的一个**大数**与前面的**小数**交换位置

- 设交换`a[i], a[k]`, 其中`i < k` 且 `a[i] <= a[k]`, `a[i]`所在的位置的权重为$10^x$, `a[k]`所在的位置的权重为$10^y$, 显然$x > y$

  则交换他们之后, 数字的上升幅度为$(a[k] - a[i]) * (10^x - 10^y)$

- 在上面的式子中, $(a[k] - a[i]) <= 9, (10^ x - 10^y) >= 9$, 也就是说, 距离差对于数字的涨幅权重更大

- 算法流程

  - **从后向前**查找第一个**相邻升序**的元素对 `(i,j)`，满足 `A[i] < A[j]`。此时 `[j,end)` 必然是降序

  - 在 `[j,end)` **从后向前**查找第一个满足 `A[i] < A[k]` 的 `k`。`A[i]`、`A[k]` 分别就是上文所说的「小数」、「大数」

    > 为什么交换a[i], a[k]?
    >
    > - 假设交换的两个值均位于j右侧, 则交换之后, 数值必然会减少, 不合法
    >
    > - 假设交换的两个值一个均位于`j`左侧, 交换之后的数字上升幅度为$(a[k] - a[i]) * (10^x - 10^y)$
    >
    >   如果交换的两个值一个位于`j`左侧, 一个位于`j`右侧, 则交换之后上升幅度为$(a[k] - a[i]) * (10^{x'} - 10^{y'})$
    >
    >   两个均位于左侧的幅度要更大

  - 当交换完毕之后, `[j, end)`必然依旧是降序, 此时将其反转, 使其变为升序, 数值进一步缩小到最小

  ![fig1](https://assets.leetcode-cn.com/solution-static/31/31.gif)

**代码实现**

```cc
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int n = nums.size(), i = nums.size() - 2;
        for (; i >= 0; i --) {
            if (nums[i + 1] > nums[i]) break ;
        } 
        
        // 当 i == -1时, 就表明整个数组是降序数组, 直接反转
        if (i != -1) {
            for (int k = n - 1; k >= i + 1; k --) {
                if (nums[k] > nums[i]) {
                    swap(nums[k], nums[i]);
                    break ;
                }
            }
        }

        reverse(nums.begin() + i + 1, nums.end());
    }
};
```

