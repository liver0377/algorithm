### 新年好

![image-20220806170733374](http://www.cdn.liver0377.xyz/typora/202208061707435.png)

![image-20220806170746605](http://www.cdn.liver0377.xyz/typora/202208061707638.png)



**算法类型**

- 最短路 + `dfs`



**解题思路**

- 此题的朴素思想是暴力枚举出访问亲戚的顺序，然后按照顺序求最短路即可
- 若采用堆优化`Dijkstra`，采用`dfs`枚举访问顺序，时间复杂度为$O(5! * 6 * m * lgn)$, 可能会超时
- 可以采用空间换时间的方法，首先预处理出以不同的亲戚为起点，到达其它点的最短路径，存储在数组当中
- 接下来就`dfs`是就可以直接进行查表操作，时间复杂度缩减为$O(5! + 6 * m * lgn)$



**代码实现**

```cc
#include <iostream>
#include <algorithm>
#include <queue>
#include <cstring>

using namespace std;

const int N = 5e4 + 10;
const int M = (1e5 + 10) * 2;

typedef pair<int, int> PII;
int h[N], e[M], ne[M], w[M], idx;
int dist[6][N];
bool visited[6];
bool st[N];
int sources[6];
int n, m;

void add(int a, int b, int c) {
    w[idx] = c, e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

void dijkstra(int start) {
    memset(st, 0, sizeof st);
    
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    int stop = sources[start];
    dist[start][stop] = 0;
    heap.push({0, stop});
    
    while (heap.size()) {
        PII t = heap.top();
        heap.pop();
        
        int v = t.second;
        if (st[v]) continue;
        st[v] = true;
        
        for (int i = h[v]; i != -1; i = ne[i]) {
            int j = e[i];
            if (dist[start][j] > dist[start][v] + w[i]) {
                dist[start][j] = dist[start][v] + w[i];
                heap.push({dist[start][j], j});
            }
        }
    }
}

int dfs(int level, int idx, int cost) {
    if (level == 6) return cost;
    
    int res = 0x3f3f3f3f;
    for (int i = 1; i <= 5; i++) {
        if (visited[i]) continue;
        int stop = sources[i];
        visited[i] = true;
        res = min(res,  dfs(level + 1, i, cost + dist[idx][stop]));
        visited[i] = false;
    }
    
    return res;
}
int main() {
    cin >> n >> m;
    sources[0] = 1;
    for (int i = 1; i <= 5; i++) cin >> sources[i];
    
    memset(h, -1, sizeof h);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
        add(b, a, c);
    }
    
    memset(dist, 0x3f, sizeof dist);
    for (int i = 0; i < 6; i++) {
        dijkstra(i);
    }
    
    
    cout << dfs(1, 0, 0);
    return 0;
}
```







### 通信线路

![image-20220806195441949](http://www.cdn.liver0377.xyz/typora/202208061954013.png)

![image-20220806195453092](http://www.cdn.liver0377.xyz/typora/202208061954135.png)





**算法类型**

- 最短路 + 双端队列`bfs` + 二分



**解题思路**

- 题意转换

  在给定无向图上求出一条从1到`N`的路径，使得路径上第`K + 1`大的路径的权重最小

- 可以采用二分将所有边一分为二

- 给定一个`mid`，将权值大于`mid`的边的权值替换为1， 权值小于`mid`的边替换为0，这样整张图就变成了只含有权值0， 1的无向图

- `mid`的选取要满足如下条件：

  - 权值大于`mid`的边不大于`K`条
  - `mid`尽可能小

  也就是二分过后使得`mid`右边的边的数目不大于`K`个, j此时`mid`就是本题的答案

  之所以不是等于`K`,是因为可能会有`K`大于等于路径长度的情况

- 由于权重全部变为了0,1，因此要想求`mid`右侧的边的数目，只需要求出图中从1到`N`的**最短路**即可

  因为只要最短路的大小不大于`K`，那么就找到了目标路径

  由于这里权值只有0,1，因此可以使用双端队列`bfs`求最短路

- 二分的范围

  - 左边界为0，因为0是一个合法解，当`K`大于等于最短路时，不用花钱

  - 右边界为1e6 + 1, 主要是为了将无解的情况与解为1e6的情况区分开

    - 如果最终二分出来的答案为1e6, 那么说明有解

    - 如果最终二分出来的答案为1e6 + 1， 那么说明无解，可以将无解情况看做是路径上存在一条长度为无穷的边，这样二

      分时就会不断地向右靠拢

**代码实现**

```cc
#include <iostream>
#include <algorithm>
#include <cstring>
#include <deque>

using namespace std;

const int N = 1010;
const int M = (1e4 + 10) * 2;

int h[N], e[M], ne[M], w[M], idx;
int st[N];
int dist[N];
int n, m, k;

bool check(int bound) {
    memset(st, 0, sizeof st);
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    deque<int> q;
    q.push_front(1); 
    
    while (q.size()) {
        int t = q.front();
        q.pop_front();
        
        if (st[t]) continue;
        st[t] = true;
        
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            int v = w[i] > bound;   // 根据当前边的权重赋予0还是1
            if (dist[j] > dist[t] + v) {
                dist[j] = dist[t] + v;
            }
            
            if (!v) {
                q.push_front(j);
            } else {
                q.push_back(j);
            }
        }
    }
    
    return dist[n] <= k;
}

void add(int a, int b, int c) {
    w[idx] = c, e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

int main() {
    cin >> n >> m >> k;
    memset(h, -1, sizeof h);
    
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
        add(b, a, c);
    }
    
    int l = 0, r = 1e6 + 1;
    while (l < r) {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    
    if (l != 1e6 + 1) {
        cout << l << endl;
    } else {
        cout << -1 << endl;
    }
    
    return 0;
}
```

