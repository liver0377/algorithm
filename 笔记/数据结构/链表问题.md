### 链表反转

链表反转有三种方式

**prev, cur同步向前(推荐)**

- 定义两个指针： pre 和 cur, pre 在前 cur 在后
- 每次让 pre 的 next 指向 cur ，实现一次局部反转
- 局部反转完成之后，pre 和 cur 同时往前移动一个位置
- 循环上述过程，直至 pre 到达链表尾部

![img](https://pic.leetcode-cn.com/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif)

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* cur = head;
        ListNode* pre = nullptr;

        while (cur != nullptr) {
            ListNode* nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }

        return pre;
    }
};
```

> 该方法最终状态时: `pre`指向最后一个节点, `cur`指向空



**递归**(不推荐)

- 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 ret
- 此后，每次函数在返回的过程中，让当前结点的下一个结点的 nextnext 指针指向当前节点。
- 同时让当前结点的 next 指针指向 NULL ，从而实现从链表尾部开始的局部反转
- 当递归函数全部出栈后，链表反转完成

![img](https://pic.leetcode-cn.com/8951bc3b8b7eb4da2a46063c1bb96932e7a69910c0a93d973bd8aa5517e59fc8.gif)

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == NULL || head->next == NULL) {
            return head;
        }
        ListNode* ret = reverseList(head->next);
        head->next->next = head;
        head->next = NULL;
        return ret;
    }
};
```



**双指针**(不推荐)

![img](https://pic.leetcode-cn.com/1c8927d9ff605502793d81ab344dbc17e16d6db2d8dd789045f56af432079519.gif)

```cpp
ListNode* reverseList(ListNode* head) {
        if (!head) return head;
        ListNode *h = new ListNode(-1, head);
        ListNode *prev = h;
        ListNode *cur = head;
        while(cur->next) {
            ListNode *t = cur->next;
            cur->next = t->next;
            t->next = prev->next;
            prev->next = t;
        }
        return h->next;
}
```







### 链表部分反转

链表部分反转依旧使用与链表反转相同的同步向前法求解

![image-20230108210343369](http://www.cdn.liver0377.xyz/typora/202301082103689.png)

- 假设要反转蓝色区域

- 那么首先要找到反转起点的前一个点`p0`

- 对蓝色区域使用同步向前法反转

  ![image-20230108210813865](D:/Typora/pics/image-20230108210813865.png)

- 反转之后, `pre`依旧指向反转的最后一个节点, `cur`指向`pre`后面的节点

- 此时, 将`p0->next->next`修改为`cur, ` `p0->next = pre`

  ![image-20230108211010704](D:/Typora/pics/image-20230108211010704.png)

- 此时可能会有一个问题:反转的开头节点就是链表起点, 此时`p0`将不存在

- 解决方案是使用一个哨兵节点, 这样可以保证`p0`节点存在



```cc
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode* sentinel = new ListNode(-1, head);
        ListNode* p0 = sentinel;
        for (int i = 0; i < left - 1; i ++) {
            p0 = p0->next;
        }
        
        ListNode* pre = nullptr;
        ListNode* cur = p0->next;
        for (int i = 0; i < right - left + 1; i ++) {
            ListNode *nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        
        p0->next->next = cur;
        p0->next = pre;

        return sentinel->next;
    }
};
```



### K个一组翻转链表

K个一组翻转链表的基本做法还是采用同步前进法, 只不过需要判断接下来是否要翻转, 而且还要特殊处理一下`p0`指针的指向

- 将1, 2局部翻转之后, `p0, pre, cur`各个指针的指向如图

  ![image-20230108214017292](D:/Typora/pics/image-20230108214017292.png)

- 此时相对于部分翻转而言, 需要额外更新`p0`, `p0`应该指向1, 也就是翻转之前链表中的`p0->next`

  可以提前使用一个变量`nxt`将其存起来





```cc
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        int n = 0;
        ListNode* cur = head;
        
        while (cur != nullptr) {
            cur = cur->next;
            n ++;
        }

        ListNode* sentinel = new ListNode(-1, head);
        ListNode* p0 = sentinel;
        
        ListNode* pre = nullptr;
        cur = p0->next;

        while (n >= k) {
            n -= k;
            
            for (int i = 0; i < k; i ++) {
                ListNode* nxt = cur->next;
                cur->next = pre;
                pre = cur;
                cur = nxt;
            }

            ListNode* nxt = p0->next;  // 提前存储p0->next, 因为其接下来要被改变
            p0->next->next = cur;
            p0->next = pre;
            p0 = nxt;  // 更新p0
        }

        return sentinel->next;
    }
};
```



### 链表的环

**判断是否有环**

- 龟兔赛跑算法可以用于确定一个链表中是否存在环

- 使用`slow, fast`两个指针, 初始时令它们都指向链表首位置
- 令`fast`每次移动两步, `slow`每次移动一步
- 如果链表中有环, 则`fast`指针一定会追上`slow`指针
- 如果遇到了空节点, 那么肯定没有环

```cpp
 bool hasCycle(ListNode *head) {
        if (!head || !head->next) {
            return false;
        }

        ListNode *slow = head;
        ListNode *fast = head;
        while (true) {
            if (!fast || !fast->next){
                return false;
            }
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow) break ;
        }
        return true;
}
```



**判断环的起始点**

使用以下流程判断环的起点

- 设置`slow, fast`两个指针, 初始值, 令它们都指向链表首部
- 依旧采用龟兔赛跑方法, 令`fast`指针每次移动两步, `slow`指针每次移动一步
- 当两指针第一次相遇时, `slow`保持不变, 令`fast`指向链表的头部, 两指针均每次一步继续移动
- 当两指针再次相遇时, 相遇点即为环的起点



- 证明

  - 记`a`为起始点到环首位置的距离, `b`为环的长度

  - 当两个节点第一次相遇时, 记`s`为`slow`指针距离链表首部移动的距离, 记`f`为`fast`指针距离链表指针移动的距离

    则有

    - $f - s = k * b$
    - $f = 2 * s$

    根据上式可以推导出

    $s = n * b, f = 2 * n * b$

    即快指针比慢指针多跑了几个环

  - 此时将`fast`指针置于链表首部, `slow`置于链表尾部

  - 当经过`a`次移动之后, $s = n * b + a, f = a$

    此时它们正好都位于环的起始点, 即第二次相遇



- 模板

  ```cc
  ListNode *detectCycle(ListNode *head) {
          ListNode *f = head, *s = head;
          
          while (true) {
              if (!f || !f->next) return nullptr;
              f = f->next->next;
              s = s->next;
              if (f == s) break ;
          }
          f = head;
          while (true) {
              if (f == s) break;
              f = f->next;
              s = s->next;
          }
          return f;
      }
  ```






### 链表的中间节点

给定一个头结点为 `head` 的非空单链表，返回链表的中间结点

如果有两个中间结点，则返回第二个中间结点



- 使用快慢指针求解

- 快指针每次走两步, 慢指针每次走一步, 当快指针走到终点时,  慢指针所指的位置就是中间节点

- 根据链表长度的奇偶性, 需要进行分类讨论

  - 链表的长度为奇数

    ![image-20221209201041158](D:/Typora/pics/image-20221209201041158.png)

    此时`f`走到最后一个非空节点即可

  - 链表长度为偶数

    ![image-20221209201122767](D:/Typora/pics/image-20221209201122767.png)

    此时`f`需要走到最后的空节点

  综合考虑以上两种情况, 当`f`发现`next`或者`next.next`为空时, 即可以退出



- 模板

  ```cc
  ListNode* middleNode(ListNode* head) {
          ListNode *fast = head, *slow = head;
  
          while (fast && fast->next) {
              fast = fast->next;
              fast = fast->next;
              slow = slow->next;
          }
  
          return slow;
      }
  ```

  



