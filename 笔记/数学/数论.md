### 判断质数

**模板**

```cpp
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )              // 注意循环条件
        if (x % i == 0)
            return false;
    return true;
}
```

- 判断条件的选择
  - i < n和i <= n / 2时间复杂度都是O(n)，过高
  - i * i <= n虽然时间复杂度是$O(\sqrt{n})$，但i * i可能会溢出
  - 因此最好的判别条件是i <= n / i，时间复杂度是$O(\sqrt{n})$

### 分解质因数

**模板**

```cpp
void get_prim(int n) {
    if (n < 2) return;
    
    for (int i = 2; i <= n / i; i++) {
        if (n % i == 0) {
            int cnt = 0;
            while (n % i == 0) {
                cnt ++;
                n /= i;
            }
            printf("%d %d\n", i, cnt);
        }
    }
    if (n > 1)       // 如果n > 1, 那么代表n此时是原来的n的唯一一个大于根号n的质因子
        printf("%d %d\n", n, 1);
}
```

- 注意这里如果n%i == 0的话，n一定不是合数

  - 反证法

    假设n % i == 0, 且i 为合数，那么一定有i = a * b(a, b < i ), 不妨令a <= b

    则有n % a == 0,又a < i , 所以在之前的循环当中，n /= a一定会发生，那么现在的n将不会存在

- 时间复杂度分析

  - 最好情况：log(n), 如果n == i^k ,那么在while循环当中，n就会一次性被除到1
  - 最坏情况: $\sqrt{n}$

  

### 筛选质数

**埃氏筛法**

从1\~n之间，遍历所有的质数，筛掉它们的倍数，当遍历到i时，如果i还没有被筛掉，那么表明1\~ i - 1之间没有i的质因子，因此i就是质数

由于所有的合数可以分解出质因子，因此只要选出所有质数的倍数，就会筛掉所有合数

```cpp
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];             // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) {
            primes[cnt++] = i;                  // i是当前可用的最小质数，保存到primes中
            for (int j = i + i; j <= n; j += i)
                st[j] = true;                   // 素数的倍数一定不是素数
        }
    }
}
```

- 时间复杂度:$O(nloglogn)$



**线性筛法**

线性筛选法相对于埃氏筛选法更为出色，因为在埃是筛选法中，一个数可能会被不同的质因子重复筛掉，在线性筛选法中，对于每个合数而言，都只会用其最小的质因子来将其筛去，并且**不会发生重复筛选**的情况

```cpp
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;       // 用最小质因子pr去筛合数primes[j] * i
                                            // 这里的i会逐渐从2增长到n, 如primes[0] = 2
                                            // 那么就会筛掉2 * 2, 2 * 3, 2 * 4, ... 2 * n
                                            // 如果新加入了一个质数7, 则会2 * 7, 3 * 7, 5 * 7, 7 * 7
                                            // 这些被筛掉的数是不会重复的
            if (i % primes[j] == 0) break;  // 从最小的质数开始，直至找到i的最小质因子primes[j]为止
        }
    }
}
```

- 一句话:  对于任意一个合数x, 假设pj是其最小的质因子，那么当**i**枚举到x / pj时，x就会被筛掉