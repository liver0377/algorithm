**题干**

![image-20220527184416431](http://www.cdn.liver0377.xyz/typora/202205271844502.png)

![image-20220527184429084](http://www.cdn.liver0377.xyz/typora/202205271844129.png)



**解题思路**

- 假设有货币系统(n, a)A, 另一个货币系统(m, b)B与其等价，并且m最小

- 此时有如下性质:

  - A 集合中不能被其他数组成的数一定会在 B 集合中出现

    - 反证法:

      - 假设有`x`属于A, `x`在A集合中不能被除自己以外的其它数表示**(1)**, 且有`x`不属于B集合

      - 由于`x`在A中可以被自身表示, A B 等价, 因此`x`可以在B中被表示

        即$x = k_1 * b_1 + k_2 * b_2 + ...$m, $x > b_i$

      - 则在$\{b_1, b_2, ...\}$这些数中, 至少有一个数$b_i$不能够被A组合出来 **(2)**

        - 反证法:

          - 假设所有的$b_i$都能被A组合出来, 那么$x = k_1 * b_1 + k_2 * b_2 + ...$也就能够被A组合出来,

            并且$k_1 * b_1 + k_2 * b_2 + ...$ 一定不等于$x$本身, 因为$x > b_i$

          - 即`x`能够被A中除自己之外的元素表示, 与(1)矛盾

      - 由于$b_i$属于B集合,因此$b_i$可以被B中的自身表示

      - B与A等价, 因此$b_i$一定可以被A中的元素组合, 与(2)矛盾

      - 得证

  - $B ⊆ A$

    - 反证法:

      - 设存在一个数 `x` 满足 x∈B且 x∉A

      - 由于$x \in B$且A, B等价, 因此$x$可以被A组合, 即$x = k_1 * a_1 + k_2 * a_2 + ...$, $a_i$不可被A中的其它面值组合

        这种方案一定是存在的

      - 根据性质1可以得到, $a_1, a_2,...$一定存在于B中, 那么`x`在B就可以被其它元素组成, B一定不是最优的

    

- 什么情况下m最小？

  对给定的货币系统(n, a), 对a进行排序，设其任意一个元素$a_k$

  - 若$a_k$能够被其它$a_{k'}$表示, 那么$a_k$一定就是一个没有用的元素，在最优解(m, b)一定不会出现
  - 因此，只需要遍历一遍a集合，将所有能够被前面的元素所表示的元素删除，那么就能够得到一个最优解



**题解**

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 110;
const int M = 25010;

int f[M];   // f[i]: 从a0~a{i - 1}中，凑成a[i]的方案数
int a[N];
int T;

int main() {
    cin >> T;
    
    while (T --) {
        int n;
        cin >> n;
        for (int i = 0; i < n; i++) cin >> a[i];
        
        sort(a, a + n);
        memset(f, 0, sizeof f);
        f[0] = 1;
        
        int m = a[n - 1];
        int res = 0;
        for (int i = 0; i < n; i++) {
            if (!f[a[i]]) res ++;   // 在遍历到a[i]时, 此时的f[k]表示的是：
                                    // 使用a0~a{i - 1}的情况下，凑出k的方案数, 0 <= k <= m
                                    // 仅当方案数为0时，才保留a[i]
            for (int j = a[i]; j <= m; j++) {   // 这里判断一下能否用a[i]组成其它的数值
                                                // 只要j - a[i]可以被组成, 那么f[j]就可以被j - a[i]和a[i]组成
                f[j] += f[j - a[i]];
            }
        }

        cout << res << endl;
    }
    return 0;
}
```

