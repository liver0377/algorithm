### 并查集

并查集是一种动态维护若干个不重复的集合，并支持合并与查询的数据结构， 包含如下两个基本操作

- `Get`, 查询一个元素属于哪个集合
- `Merge`, 将两个集合合并成一个大集合



**存储**

通常使用一个树形结构存储每个集合，书上的每个节点都是一个元素，树根是**代表元**，整个并查集其实是一个森林

- 使用`fa[i]`表示元素`i`的父亲节点，根节点的`fa`为其自身

- 对于`Get`操作，需要从节点`i`不断对`fa`进行递归访问，获取到根节点的值
- 对于`Merge`操作，对应到数据结构上，就是连接两颗树的树根, 即令`fa[root1] = root2`



**路径压缩**

在并查集当中，树的结构并不重要，我们只需关心每个集合对应的树形结构的根节点，下面的两棵树是等价的

![image-20220829144843743](http://www.cdn.liver0377.xyz/typora/202208291448825.png)

- 因此可以采取一个优化措施，每次`Get`时，均直接把元素`i`指向根节点

  也就是将左边的树变为右边的树，这种方法被称为路径压缩，每次`Get`, `Merge`操作的时间复杂度为$O(log(n))$



> 实际上还存在按秩合并的优化措施，但是使用的不是很多，这里忽略



**模板**

下面的模板采用了路径压缩优化

```cc
int get(int x, int y) {
    if (x == fa[x]) return x;
    return fa[x] = get(fa[x]);
}

void merge(int x, int y) {
    fa[get(x)] = get(y);
}
```





### 边带权的并查集

有时题目可能会要求给出不同节点之间的相对关系，此时使用普通的并查集可能就无法求解，需要使用到边带权的并查集, 也就是给并查

集的边赋予权值

通常情况，使用到边带权的并查集都会和路径压缩一起使用

- 设`d[i]`表示`i`与`fa[i]`之间的距离, 注意这里的`fa[i]`是指路径压缩之后的父亲节点
- 当在进行`Get`操作以及`Merge`操作时，此时不仅需要更新`fa`, 还需要更新`d`数组



**模板**

这里是[acwing.238](https://www.acwing.com/problem/content/description/240/)的写法

```cc
memset(d, 0, sizeof d);
memset(sz, 1, sizeof sz);

int get(int x) {
    if (x == fa[x]) return x;
    int root = get(fa[x]);       
    // 当执行完get(fa[x])之后，fa[x]要么是根节点，要么是根节点的直接子节点
    d[x] += d[fa[x]];    
    return fa[x] = root;
}

void merge(int x, int y) {
    x = get(x), y = get(y);
    fa[x] = y, d[x] = sz[y];
    sz[y] += sz[x];
}
```



