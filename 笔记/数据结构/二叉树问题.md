### 验证一棵树为二叉搜索树

**二叉搜索树的定义**

![image-20230111215058002](http://www.cdn.liver0377.xyz/typora/202301112150570.png)

**前序遍历求解**

- 二叉搜索树中, 每个节点的值的范围均为它们的父节点所约束

  ![image-20230111215303826](D:/Typora/pics/image-20230111215303826.png)

  - 这里全部使用开区间表示
  - 如果一个节点是父亲节点的左孩子, 那么它的右边界即为父亲节点的值
  - 如果一个节点是父亲节点的右孩子, 那么它的左边界即为父亲节点的值

- 直接前序遍历整颗二叉树, 遍历过程中维护每个节点的范围边界, 判断当前节点的值是否越界

- 如果所有节点都没有越界, 那么当前树是一棵合法的二叉搜索树



**模板**

```cc
class Solution {
public:
    typedef long long LL;

    const LL INF = (LL)INT_MAX + 10;

    bool isValidBST(TreeNode* root, LL left, LL right) {
        if (root == nullptr) {
            return true;
        }

        int root_val = root->val;
        return left < root_val && right > root_val && 
               isValidBST(root->left, left, root->val) && 
               isValidBST(root->right, root_val, right); 
    }

    bool isValidBST(TreeNode* root) {
        return isValidBST(root, -INF, INF);    
    }
};
```



**中序遍历**

- 中序遍历利用了**中序遍历二叉树可以得到一个升序序列**这个性质
- 使用一个全局变量来记录当前节点的前面一个节点的值
- 如果当前节点的值 <= 前面节点的值, 那么当前树不是二叉搜索树

```cc
class Solution {
public:
    typedef long long LL;

    LL pre = (LL)INT_MIN - 10;

    bool isValidBST(TreeNode* root) {
        if (root == nullptr) {
            return true;
        }

        if (!isValidBST(root->left)) {
            return false;
        }

        if ((LL)root->val <= pre) {
            return false;
        }

        pre = root->val;
        if (!isValidBST(root->right)) {
            return false;
        }

        return true;
    }

};
```

